<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Install rpm/deb Packages on Gentoo</title>
      <link href="2021/03/23/install-rpm-deb-packages-on-gentoo/"/>
      <url>2021/03/23/install-rpm-deb-packages-on-gentoo/</url>
      
        <content type="html"><![CDATA[<h1 id="在-gentoo-系统上“安装”-deb-rpm-包"><a href="#在-gentoo-系统上“安装”-deb-rpm-包" class="headerlink" title="在 gentoo 系统上“安装” deb/rpm 包"></a>在 gentoo 系统上“安装” deb/rpm 包</h1><h2 id="安装原理"><a href="#安装原理" class="headerlink" title="安装原理"></a>安装原理</h2><p>众所周知，与本系统包管理体系不相容的安装包不能安装在系统上。但这里的情况分两种。</p><p>第一种，安装包内可执行文件编译时对应的架构与你的系统不同。比如你不能将 arm 架构下的软件直接跑在 amd64 的系统上。这种情况属于无解，除非自己做一个中间层。</p><p>第二种，仅仅是安装包的打包方式不同。如 deb 和 rpm。对于这种情况，完全可以将安装包拆解，然后手动将解压出来的文件放到该放的位置。这样，软件依旧可以运行，也就变相地完成了”安装“。但这并不意味着所有安装包都可以采用这种方式安装，需要解决的最大问题就是依赖。</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><p>这里以 utools 为例，仅介绍安装流程，不包括如何补全依赖。</p><p>该软件只提供了 deb 安装包。</p><p>首先获得 deb 安装包。</p><p>然后，解压安装包。</p><p>解压后可以看到两个目录，control 和 data。data 目录下有 usr 和 opt 两个子目录。显然，这里存放了应该被放入系统 usr 和 opt 目录下的文件。</p><p>一般这种软件都会自动创建一个快捷方式，即.desktop 文件。先找到这个文件。utools 的 utools.desktop 文件（已修改）如下。</p><pre class="line-numbers language-none"><code class="language-none">[Desktop Entry]Name&#x3D;uToolsExec&#x3D;&#x2F;opt&#x2F;utools&#x2F;data&#x2F;opt&#x2F;uTools&#x2F;utoolsTerminal&#x3D;falseType&#x3D;ApplicationIcon&#x3D;&#x2F;opt&#x2F;utools&#x2F;data&#x2F;usr&#x2F;share&#x2F;icons&#x2F;hicolor&#x2F;512x512&#x2F;apps&#x2F;utools.pngStartupWMClass&#x3D;uToolsComment&#x3D;你的生产力工具集Categories&#x3D;System;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的文件内容是修改后的。修改之前，你可以通过<code>Exec</code>这一行看到可执行文件的位置。</p><p>找到可执行文件，直接在当前目录下运行一下，如<code>./utools</code>。如果软件可以跑起来，那基本上可以确定该软件不缺依赖，且可以直接通过相对位置找到它的配置文件等文件。对于这样的软件，建议不要直接将文件放到 usr 和 opt 下，因为这样将很难维护该软件。可以直接将整个解压出来的目录放到/opt 目录下，如/opt/utools。</p><p>将.desktop 文件修改后，放到<code>~/.local/share/applications</code>目录或者<code>/usr/share/applications</code>目录下。一般<code>/usr/share/applications</code>目录必是存放.desktop 文件的目录，前者可能因为系统或设置不同而不同。注意必须把文件修改好之后再放入。如果先放再修改，可能修改会无效，这可能是桌面环境设置造成的问题。</p><p>至此，该软件安装已经完成。</p><p>整个步骤中最关键的一步是运行可执行文件时可以运行起来，如果不能，就需要手动补全依赖或者排查其他问题。</p><p>此外，一些系统上有一些包转换工具，如 arch，可以使用特定的软件将 deb 包等转化为 arch 的安装包。如果存在该类软件（gentoo 系统由于发行源代码，可以说不存在安装包，所以也不会有这种工具），尽量采用这种方式。如果想要或者更好的维护体验，可以自己写个 ebuild。</p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug Msp430g2 Project on Linux</title>
      <link href="2021/03/23/debug-msp430g2-project-on-linux/"/>
      <url>2021/03/23/debug-msp430g2-project-on-linux/</url>
      
        <content type="html"><![CDATA[<h1 id="在-linux-上-对-MSP430G2-系列工程进行调试"><a href="#在-linux-上-对-MSP430G2-系列工程进行调试" class="headerlink" title="在 linux 上 对 MSP430G2 系列工程进行调试"></a>在 linux 上 对 MSP430G2 系列工程进行调试</h1><p>本文介绍如何在 linux 系统上对 MSP430 程序进行 debug。包括程序的编译、下载、运行、调试以及 vim 编辑器自动补全设置。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>在本方案中，需要用到的主要工具包括 TI 官方提供的 IDE——CCS，mspdebug，msp430-elf-gdb，vim/neovim。</p><p>注意，CCS 的 linux 版本不支持连接 MSP430G2 系列的开发板，否则就没那么多麻烦了。在本方案中，该 IDE 只作为编译工具使用。</p><p>TI 官方提供的 msp430-gcc 虽然可以编译程序，但是缺少部分头文件。下面将介绍配置 GCC 的相关内容，但不建议作为编译工具使用。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p>安装 CCS、mspdebug。很简单，过程略。</p><p>关于 CCS 的使用，由于只需要用来做编译器，更好的选择是使用命令行操作，避免开启图形界面，具体上网搜即可。</p><p>msp430-elf-gdb 可以从 TI 官方提供的 msp430-gcc 编译工具链中获得，也可以自己编译。自己编译的过程如下。</p><p>在 GNU 官网下载最版本 gdb。解压，进入目录。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># target是架构，不需要修改# prefix将决定最终安装gdb的位置，可以自行修改.&#x2F;configure --prefix&#x3D;&quot;$&#123;PREFIX&#125;&quot; --target&#x3D;msp430-elfmakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要拆卸 gdb，需要进入编译好后的目录中所有的子目录，执行<code>sudo make uninstall</code>。</p><p>编辑器可以自由选择，本文介绍时使用 neovim。</p><h3 id="msp430-gcc"><a href="#msp430-gcc" class="headerlink" title="msp430-gcc"></a>msp430-gcc</h3><p>如果想要尝试 gcc，可以参考以下步骤。</p><p>首先，在 TI 官网下载 msp430-gcc 及其 support-files。gcc 下载压缩包即可，不需要下载安装工具。</p><p>解压两个下载包。将 support-files 中所有的.h 与.ld 文件复制到 gcc 的 msp430-elf/include 目录以及 msp430-elf/lib 目录下。这里如果想少一点麻烦就不要参考官方教程将文件放到 include/device，直接按前述操作完成即可。</p><p>至此，gcc 配置完毕，只是仍然缺少部分头文件。如<code>delay_cycles</code>函数未定义。</p><p>想要用 gcc 编译，可以进入 msp430gcc 目录，使用<code>./bin/msp430-elf-gcc -I ./msp430-elf/include -mmcu=msp430g2553 -c main.c</code>编译。注意，必须指定微处理器的具体型号，且不要指明 lib 路径（设定处理器型号后 gcc 会自动调用链接器，不需要指明，指明后有冲突，这是前面放置头文件操作引起的）。</p><p>这样可以成功得到可执行文件。</p><p>需要注意的是，如果不介意官网提供的 gcc 版本较低，尽量使用官网的版本。自己编译的 gcc 缺少头文件等问题的情况只会更严重。如 gentoo crossdev 中编译而成的 msp430-elf-gcc，进行上述操作添加头文件后，虽然可以编译程序，但实际上是错误编译，这些可执行文件不可实际运行。这种情况下还需要做更多的处理。</p><h3 id="编辑器自动补全与语法检查"><a href="#编辑器自动补全与语法检查" class="headerlink" title="编辑器自动补全与语法检查"></a>编辑器自动补全与语法检查</h3><p>neovim 可以使用 coc.nvim，并安装 coc-clangd 插件。对于其他编辑器而言，也可以使用类似的 lsp。通用的一点是<code>compile_commands.json</code>文件，这决定了 lsp 补全与检查的依据。该文件可以使用工具从 makefile 或 CMakeList.txt 生成。</p><p>什么都不会也没有关系，直接写就行，只需要七行即可。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">[  &#123;    &quot;directory&quot;: &quot;工作目录路径&quot;,    &quot;command&quot;: &quot;编译指令，可以借用一下ccs内置的gcc，把头文件和微处理器型号写入，可参考上面的gcc编译命令&quot;,    &quot;file&quot;: &quot;需要编译的文件，如.&#x2F;main.c&quot;  &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其置于工程目录下即可。</p><p>建议将 ccs 安装目录中所有头文件复制到一个目录下，使用<code>-I</code>指定该目录即可。对于部分缺少的定义，可以自行在该目录下的头文件中添加，这样也不影响 ccs 编译程序。这里关于缺少的定义稍微解释一下。举个常见的例子，如<code>__intertupt</code>。如果你使用它，lsp 会报未定义错误，但是在 ccs 编译器中不会发生，且可以成功编译。查找所有的头文件，确实没有定义。这个时候就可以手动加上，骗过 lsp。如调用了”msp430g2553.h”，则在该头文件末尾加上<code>define __intertupt</code>。</p><h2 id="程序烧录与运行"><a href="#程序烧录与运行" class="headerlink" title="程序烧录与运行"></a>程序烧录与运行</h2><p>得到可执行文件后，使用 mspdebug 工具进行烧录。</p><pre class="line-numbers language-none"><code class="language-none">sudo mspdebug rf2500# 进入mspdebug界面load your_file# 或者prog your_file# 运行程序run# 擦除程序erase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><pre class="line-numbers language-none"><code class="language-none">sudo mspdebug rf2500gdb# 在另一个终端窗口启动gdb，具体命令看自己的gdb名称msp430-elf-gdb# 进入gdb界面# 监听上面mspdebug提供的调试端口target remote localhost:2000# moniter后加的命令相当于mspdebug下执行的命令moniter prog your_filefile your_file# 使用continue运行程序，不可使用runc# 其他调试自我发挥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSP430G2 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build aarch64 Cross Toolchain on Gentoo with Crossdev</title>
      <link href="2021/03/23/build-aarch64-cross-toolchain-on-gentoo-with-crossdev/"/>
      <url>2021/03/23/build-aarch64-cross-toolchain-on-gentoo-with-crossdev/</url>
      
        <content type="html"><![CDATA[<h1 id="gentoo-使用-crossdev-建立-aarch64-交叉编译链"><a href="#gentoo-使用-crossdev-建立-aarch64-交叉编译链" class="headerlink" title="gentoo 使用 crossdev 建立 aarch64 交叉编译链"></a>gentoo 使用 crossdev 建立 aarch64 交叉编译链</h1><p>crossdev 和 aarch64 交叉编译链的安装指令很简单，网上随处可搜到。这里主要指出其中的一个 bug。即在编译 aarch64-linux-gnu glibc 时出现<code>no such instruction</code>的 bug。该错误的意思主要是缺少汇编指令。但是并不是 binutils 的问题，而是编译 glibc 时自动选择的编译器为 gcc（应该是遵照了<code>/etc/portage/make.conf</code>中的设置，没有自动换过来），而 gcc 在系统上指的是 x86_64 的 gcc。查看是否是该原因引起的错误，看日志文件中<code>CC</code>选项。修复该错误只需要在 crossdev 命令前加上<code>CC=aarch64-unknown-linux-gnu-gcc</code>。然后在编译<code>cross-aarch64-unknown-linux-gnu-gcc-stage2</code>时，再用回 x86_64 的 gcc。</p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Develop Stm32 Project with Rust</title>
      <link href="2021/03/23/develop-stm32-project-with-rust/"/>
      <url>2021/03/23/develop-stm32-project-with-rust/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-rust-开发-stm32"><a href="#使用-rust-开发-stm32" class="headerlink" title="使用 rust 开发 stm32"></a>使用 rust 开发 stm32</h1><p>本文介绍如何用 rust 语言开发 stm32。开发平台为 linux（gentoo）。</p><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>本文使用的芯片为 STM32F103C8T6。该芯片性价比较高，价格低廉，适合入门学习。需要注意的是该款芯片为国产仿品，在烧录的时候需要对软件进行一定修改。</p><p>仿真器选用 STLINK V2。</p><p>连接时只需要按板子上的标注把相同的引脚连起来即可。</p><p>此外需要至少四根母对母杜邦线。</p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><h3 id="安装-rust"><a href="#安装-rust" class="headerlink" title="安装 rust"></a>安装 rust</h3><p>步骤极为简单，建议选用 beta 或者 nightly 版本工具链。</p><p>添加对相应架构的支持。</p><pre class="line-numbers language-none"><code class="language-none">rustup target add thumbv6m-none-eabi thumbv7m-none-eabi thumbv7em-none-eabi thumbv7em-none-eabihf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="openocd"><a href="#openocd" class="headerlink" title="openocd"></a>openocd</h3><p>用于驱动仿真器。直接搜索如何安装即可。</p><p>对以上芯片，需要进行如下修改。</p><p>找到 openocd 的安装目录，将<code>/scripts/target/stm32f1x.cfg</code>中的<code>set _CPUTAPID 0x1ba01477</code>修改为<code>set _CPUTAPID 0x2ba01477</code>。</p><h3 id="arm-none-eabi-工具链"><a href="#arm-none-eabi-工具链" class="headerlink" title="arm-none-eabi 工具链"></a>arm-none-eabi 工具链</h3><p>对 gentoo 而言，直接使用 crossdev 进行配置即可。其中 gdb 建议下载源码编译。其他 linux 版本需要搜索如何安装。</p><p>gdb 编译步骤如下。</p><pre class="line-numbers language-none"><code class="language-none"># 进入源码目录.&#x2F;configure --prefix&#x3D;&quot;$&#123;PREFIX&#125;&quot; --target&#x3D;arm-none-eabimakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果要拆卸，<code>cd</code>进入编译后的各个目录，执行<code>sudo make uninstall</code>即可。</p><p>crossdev 安装 arm-none-eabi 工具链步骤如下。</p><pre class="line-numbers language-none"><code class="language-none"># 首先安装crossdev# 编辑&#x2F;etc&#x2F;portage&#x2F;make.conf，写入PORTDIR_OVERLAY&#x3D;&quot;$&#123;PORTDIR_OVERLAY&#125; &#x2F;usr&#x2F;local&#x2F;portage&quot;# 编译安装工具链sudo crossdev -s4 -t arm-none-eabi# 如果软件编译失败，查看原因为masked by: corruption，则# 编辑&#x2F;var&#x2F;db&#x2F;repos&#x2F;localrepo-crossdev&#x2F;metadata&#x2F;layout.conf，写入masters &#x3D; gentoothin-manifests &#x3D; true# 编辑&#x2F;etc&#x2F;portage&#x2F;repos.conf&#x2F;crossdev.conf，写入[crossdev]location &#x3D; &#x2F;var&#x2F;db&#x2F;repos&#x2F;localrepo-crossdevpriority &#x3D; 10masters &#x3D; gentooauto-sync &#x3D; no# 编译时需要使用gcc作为编译器，编译newlib时，需要把&#x2F;etc&#x2F;portage&#x2F;make.conf中# COMMON_FLAGS&#x3D;&quot;-march&#x3D;native -O2 -pipe&quot;注释掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="stlink"><a href="#stlink" class="headerlink" title="stlink"></a>stlink</h3><p>stlink 是仿真器的驱动，在连接中可能需要。</p><h3 id="gdbgui（可选）"><a href="#gdbgui（可选）" class="headerlink" title="gdbgui（可选）"></a>gdbgui（可选）</h3><p>gdb gui 程序，便于调试。</p><h2 id="blink"><a href="#blink" class="headerlink" title="blink"></a>blink</h2><p>新建项目<code>cargo new rusty-blink</code>。</p><p><code>Cargo.toml</code>如下</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[package]name &#x3D; &quot;rusty-blink&quot;version &#x3D; &quot;0.1.0&quot;authors &#x3D;edition &#x3D; &quot;2018&quot;# See more keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html[profile.release]opt-level &#x3D; &#39;z&#39; # turn on maximum optimizations. We only have 64kBlto &#x3D; true      # Link-time-optimizations for further size reduction[dependencies]cortex-m &#x3D; &quot;^0.6.3&quot;      # Access to the generic ARM peripheralscortex-m-rt &#x3D; &quot;^0.6.12&quot;  # Startup code for the ARM Coreembedded-hal &#x3D; &quot;^0.2.4&quot;  # Access to generic embedded functions (&#96;set_high&#96;)panic-halt &#x3D; &quot;^0.2.0&quot;    # Panic handler# Access to the stm32f103 HAL.[dependencies.stm32f1xx-hal]# Bluepill contains a 64kB flash variant which is called &quot;medium density&quot;features &#x3D; [&quot;stm32f103&quot;, &quot;rt&quot;, &quot;medium&quot;]version &#x3D; &quot;^0.6.1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在项目根目录下新建项目配置<code>mkdir .cargo</code>。其中由于使用 lld 进行链接后会丢失调试信息，因此将 linker 指定为 gcc，。runner 是执行<code>cargo run</code>之后自动执行的命令，此处为自动开启 gdb 并加载文件。</p><pre class="line-numbers language-none"><code class="language-none"># .cargo&#x2F;config[build]target &#x3D; &quot;thumbv7m-none-eabi&quot;[target.&#39;cfg(all(target_arch &#x3D; &quot;arm&quot;, target_os &#x3D; &quot;none&quot;))&#39;]runner &#x3D; &#39;gdbgui -g arm-none-eabi-gdb&#39;[target.thumbv7m-none-eabi]rustflags &#x3D; [4&quot;-C&quot;, &quot;linker&#x3D;arm-none-eabi-gcc&quot;,4&quot;-C&quot;, &quot;link-arg&#x3D;-Wl,-Tlink.x&quot;,4&quot;-C&quot;, &quot;link-arg&#x3D;-nostartfiles&quot;,]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>在项目根目录下新建<code>memory.x</code>。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* memory.x - Linker script for the STM32F103C8T6 *&#x2F;MEMORY&#123;  &#x2F;* Flash memory begins at 0x80000000 and has a size of 64kB*&#x2F;  FLASH : ORIGIN &#x3D; 0x08000000, LENGTH &#x3D; 64K  &#x2F;* RAM begins at 0x20000000 and has a size of 20kB*&#x2F;  RAM : ORIGIN &#x3D; 0x20000000, LENGTH &#x3D; 20K&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般网上售卖的该款芯片应当是 64K 和 20K，如果有偏差需要按实际情况填写。</p><p>在 src 下新建<code>main.rs</code>。该程序仅用于测试，效果为绿灯闪烁。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F; src&#x2F;main.rs#![no_std]#![no_main]use cortex_m_rt::entry; &#x2F;&#x2F; The runtimeuse embedded_hal::digital::v2::OutputPin; &#x2F;&#x2F; the &#96;set_high&#x2F;low&#96;functionuse stm32f1xx_hal::&#123;delay::Delay, pac, prelude::*&#125;; &#x2F;&#x2F; STM32F1 specific functions#[allow(unused_imports)]use panic_halt; &#x2F;&#x2F; When a panic occurs, stop the microcontroller#[entry]fn main() -&gt; ! &#123;    let dp &#x3D; pac::Peripherals::take().unwrap();    let cp &#x3D; cortex_m::Peripherals::take().unwrap();    let mut rcc &#x3D; dp.RCC.constrain();    let mut gpioc &#x3D; dp.GPIOC.split(&amp;mut rcc.apb2);    let mut led &#x3D; gpioc.pc13.into_push_pull_output(&amp;mut gpioc.crh);    let mut flash &#x3D; dp.FLASH.constrain();    let clocks &#x3D; rcc.cfgr.sysclk(8.mhz()).freeze(&amp;mut flash.acr);    let mut delay &#x3D; Delay::new(cp.SYST, clocks);    loop &#123;        led.set_high().ok();        delay.delay_ms(1_000_u16);        led.set_low().ok();        delay.delay_ms(1_000_u16);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="烧录与调试"><a href="#烧录与调试" class="headerlink" title="烧录与调试"></a>烧录与调试</h3><pre class="line-numbers language-none"><code class="language-none"># 连接仿真器openocd -f interface&#x2F;stlink-v2.cfg -f target&#x2F;stm32f1x.cfg# 出现以下信息为连接成功Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints# 编译并开启gdbcargo run# 在gdb窗口执行以下命令target remote :3333moniter reset haltloadcontinue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时如果程序持续执行，应当可以在板子上看到绿灯闪烁。如果停在断点处，就再 continue。</p><p>更进一步可以直接在 gdb 开启时自动执行以上命令。</p><p>将<code>runner</code>改为<code>runner = &#39;arm-none-eabi-gdb -q -x debug.gdb&#39;</code>。在项目根目录下新建<code>debug.gdb</code>，写入以下内容。</p><pre class="line-numbers language-none"><code class="language-none">target remote :3333set backtrace limit 32monitor reset haltload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stm32 </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Install Oracle Jdk and Jre on Gentoo</title>
      <link href="2021/03/23/install-oracle-jdk-and-jre-on-gentoo/"/>
      <url>2021/03/23/install-oracle-jdk-and-jre-on-gentoo/</url>
      
        <content type="html"><![CDATA[<h1 id="Gentoo系统安装Oracle-jdk和jre"><a href="#Gentoo系统安装Oracle-jdk和jre" class="headerlink" title="Gentoo系统安装Oracle jdk和jre"></a>Gentoo系统安装Oracle jdk和jre</h1><h2 id="why-not-openjdk"><a href="#why-not-openjdk" class="headerlink" title="why not openjdk"></a>why not openjdk</h2><p>openjdk 在部分情况下无法完全替代闭源版本。尤其是在需要完整 javafx 的情况下。</p><p>gentoo 提供了具有 javafx USE flag 的 openjdk。不过笔者未能成功开启，应该是与主 profile 冲突。另外也有提供 openjfx，不过该 javafx 属于阉割版，比如没有对 webkit 的支持。</p><h2 id="通过包管理器安装"><a href="#通过包管理器安装" class="headerlink" title="通过包管理器安装"></a>通过包管理器安装</h2><p>gentoo overlay 中有 oracle-jdk-bin 的 ebuild，希望通过包管理系统安装的可以使用。但是由于 oracle 禁止从链接直接获取二进制包。必须手动下载合适版本，放入指定位置后才可编译。</p><p>该方案有几个缺点。一是 overlay 上没有提供最新版本。二是由于指定位置实际上是个临时文件夹，也就是说每次 emerge 都会改变位置。然而等你获取提示中的位置信息时，再将下载的文件放入已经无效。笔者未曾遇到过这种问题，偷懒放弃解决。实在解决不了的可以把人家的 ebuild copy 到自己的 overlay 中，改链接到你上传下载的 jdk、jre 的地址也行。</p><h2 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h2><p>从 oracle <a href="https://www.oracle.com/java/technologies/javase-downloads.html">官网</a> 下载 jdk。以 oracle-jdk8u271 为例。</p><ol><li>解压。</li><li>将其移动到合适位置并赋予权限。</li></ol><pre class="line-numbers language-none"><code class="language-none">tar xvzf XXXsudo chown -R 777 XXXmv XXX XXX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>XXX</code>部分自行填写。</p><ol start="3"><li>配置 java 信息。</li></ol><p>编辑<code>/usr/share/java-config-2/vm/oracle-jdk8u271</code>。写入</p><pre class="line-numbers language-none"><code class="language-none">VERSION&#x3D;&quot;Oracle-Sun JDK 8u271&quot;JAVA_HOME&#x3D;&quot;&#x2F;opt&#x2F;jdk1.8.0_271&quot;JDK_HOME&#x3D;&quot;&#x2F;opt&#x2F;jdk1.8.0_271&quot;JAVAC&#x3D;&quot;$&#123;JAVA_HOME&#125;&#x2F;bin&#x2F;javac&quot;PATH&#x3D;&quot;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;bin&quot;ROOTPATH&#x3D;&quot;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;bin&quot;LDPATH&#x3D;&quot;$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;native_threads&#x2F;:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;xawt&#x2F;:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;server&#x2F;&quot;MANPATH&#x3D;&quot;&#x2F;opt&#x2F;icedtea-bin-8.2.2.1&#x2F;man&quot;PROVIDES_TYPE&#x3D;&quot;JDK JRE&quot;PROVIDES_VERSION&#x3D;&quot;1.8&quot;# Taken from sun.boot.class.path propertyBOOTCLASSPATH&#x3D;&quot;$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;resources.jar:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;jsse.jar:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;jce.jar:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;charsets.jar&quot;GENERATION&#x3D;&quot;2&quot;ENV_VARS&#x3D;&quot;JAVA_HOME JDK_HOME JAVAC PATH ROOTPATH LDPATH MANPATH&quot;VMHANDLE&#x3D;&quot;oracle-jdk8&quot;BUILD_ONLY&#x3D;&quot;FALSE&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意修改版本号。</p><ol start="4"><li>将 jdk 文件夹软链接到<code>/usr/lib/jvm</code>。</li></ol><p>如<code>ln -s /opt/jdk1.8.0_271/ /usr/lib/jvm/oracle-jdk8u271</code>。</p><ol start="5"><li>设置 java 版本。</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 查看当前可用的java虚拟机。eselect java-vm list&#x2F;&#x2F; 设置虚拟机，不可使用sudo。eselect java-vm set user number&#x2F;&#x2F; 或者eselect java-vm set system number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他 linux 版本可以通过<code>java-config -L</code>查看，<code>java-config set number</code>设置。（该操作对 gentoo 无效）</p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
            <tag> Java </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Fuzzy Search Plugin</title>
      <link href="2021/03/23/vim-fuzzy-search-plugin/"/>
      <url>2021/03/23/vim-fuzzy-search-plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-模糊搜索"><a href="#vim-模糊搜索" class="headerlink" title="vim 模糊搜索"></a>vim 模糊搜索</h1><p>本文主要介绍 vim 高性能模糊查找插件 vim-clap。另外也推荐尝试 coc.nvim 自带的 coc list。</p><h2 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h2><p>模糊查找的内容包括编辑文件历史、文件内容、mark、tags、vim 主题、buffers、windows、quickfix 等等。</p><p>这些功能在一些 IDE 与 vscode 等编辑器中有直接的集成。而在 vim 中，需要自己扩展。</p><p>vim-clap 的效果图可以查看其<a href="https://github.com/liuchengxu/vim-clap">github 主页</a>。</p><h2 id="vim-clap"><a href="#vim-clap" class="headerlink" title="vim-clap"></a>vim-clap</h2><p>vim-clap 是一款后端用 rust 语言开发的模糊查找插件，因此速度非常快。</p><h3 id="vim-clap-安装"><a href="#vim-clap-安装" class="headerlink" title="vim-clap 安装"></a>vim-clap 安装</h3><p>首先，最好先配置好 rust 语言环境（不配应该也可以）。使用 rustup 安装 rust 语言编译链及配套工具。这一部分可以参考 rust 官方文档，此处不做介绍。提示一下，官方给的安装 rustup 的链接并没有被墙，无需翻墙。</p><p>安装好之后，如果嫌速度慢，可以换上中科大的源。网上教程很多，此处不再介绍。</p><p>如果你已经完成了上述所有步骤，则可以按照文档给出的 vim-plug 配置安装插件。如果你没有完成上述步骤，使用<code>Plug &#39;liuchengxu/vim-clap&#39;, &#123; &#39;do&#39;: &#123; -&gt; clap#installer#force_download() &#125; &#125;</code>来安装你的插件。vim-plug 将在下载好插件之后继续编译或者下载其 rust 依赖。</p><h3 id="vim-clap-配置"><a href="#vim-clap-配置" class="headerlink" title="vim-clap 配置"></a>vim-clap 配置</h3><p>该插件的默认配置已经很完善，你完全可以直接使用。</p><p>该插件的默认快捷键在官方文档中有介绍。其命令也很简单，只需要<code>:Clap xxx</code>，<code>xxx</code>表示你想要搜索的内容。可选的内容在文档中也已经列出。</p><p>最后给出笔者的快捷键配置方案，仅供参考。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; vim-clapnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;op  :&lt;C-u&gt;Clap&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;ob  :&lt;C-u&gt;Clap buffers&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;oc  :&lt;C-u&gt;Clap command&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;oh  :&lt;C-u&gt;Clap history&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;of  :&lt;C-u&gt;Clap files ++finder&#x3D;rg --ignore --hidden --files&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;oq  :&lt;C-u&gt;Clap quickfix&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;oj  :&lt;C-u&gt;Clap jumps&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;om  :&lt;C-u&gt;Clap marks&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;ow  :&lt;C-u&gt;Clap windows&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;ot  :&lt;C-u&gt;Clap tags&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;os  :&lt;C-u&gt;Clap colors&lt;CR&gt;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;og :&lt;C-u&gt;Clap grep2&lt;CR&gt;let g:which_key_map1.o &#x3D; &#123;444\ &#39;name&#39; : &#39;+clap&#39;,444\ &#39;p&#39; : &#39;clap&#39;,444\ &#39;b&#39; : &#39;buffers&#39;,444\ &#39;c&#39; : &#39;command&#39;,444\ &#39;h&#39; : &#39;file history&#39;,444\ &#39;f&#39; : &#39;search file&#39;,444\ &#39;q&#39; : &#39;quickfix list&#39;,444\ &#39;j&#39; : &#39;jumps&#39;,444\ &#39;m&#39; : &#39;marks&#39;,444\ &#39;w&#39; : &#39;windows&#39;,444\ &#39;t&#39; : &#39;tags&#39;,444\ &#39;s&#39; : &#39;colors&#39;,444\ &#39;g&#39; : &#39;find word&#39;,444\ &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="coc-list"><a href="#coc-list" class="headerlink" title="coc list"></a>coc list</h2><p>coc list 是 coc.nvim 自带的模糊查找功能模块。它不仅可以用于控制补全源、lsp 等的开关，coc 插件的调用，也具有部分模糊查找的功能，不过功能暂时还没有那么强大，并不支持那么多内容的查找。有兴趣的可以自行研究。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Clipboard History Plugin</title>
      <link href="2021/03/23/vim-clipboard-history-plugin/"/>
      <url>2021/03/23/vim-clipboard-history-plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="vim剪贴板历史记录插件"><a href="#vim剪贴板历史记录插件" class="headerlink" title="vim剪贴板历史记录插件"></a>vim剪贴板历史记录插件</h1><p>本文介绍 vim 剪贴板历史管理插件。</p><h2 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h2><p>vimer 们在疯狂码字的过程中常会被一个问题打断操作。那就是多次复制与粘贴的冲突。vim 的默认规则是，粘贴的必是最后一次复制的内容。如此，当遇到像要交换两个内容时，就会遇到无法同时复制再粘贴的情况。随着 vim 提供了非常多寄存器，但是，一来，使用寄存器需要多按键，二来，时间一长，你就很难记得那个寄存器里放了什么，又需要手动查看。</p><p>如果有了剪贴板历史插件，一切问题就都将迎刃而解。</p><h2 id="插件选择"><a href="#插件选择" class="headerlink" title="插件选择"></a>插件选择</h2><p>可以选择 YankRing。这算是一个比较古老的插件，很多年没有更新了，但是功能很完善，也十分稳定。只是该插件有部分命令是直接绑死快捷键的，如<code>&lt;C-n&gt;</code>，这意味着你不能再为该键位绑定其他命令。</p><p>如果你介意这一点，且使用<code>coc.nvim</code>插件，可以采用<code>coc-yank</code>插件。该 coc 插件提供了相同的功能。此外，该插件还可以设置复制区域高亮，即高亮显示你的复制内容。插件的配置非常简单，此处不再赘述，仅给出简单的示例。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; coc-yanknnoremap &lt;silent&gt; &lt;space&gt;p  :&lt;C-u&gt;CocList -A --normal yank&lt;cr&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Markdown Preview Plugin</title>
      <link href="2021/03/23/vim-markdown-preview-plugin/"/>
      <url>2021/03/23/vim-markdown-preview-plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-markdown预览插件"><a href="#vim-markdown预览插件" class="headerlink" title="vim markdown预览插件"></a>vim markdown预览插件</h1><p>本文主要介绍 markdown 预览插件 vim-markdown-composer 以及 markdown-preview.nvim。</p><h2 id="markdown-预览"><a href="#markdown-预览" class="headerlink" title="markdown 预览"></a>markdown 预览</h2><p>vim 没有内置 markdown 预览功能，也没有办法直接在终端预览。现有的 vim markdown 预览插件多是通过浏览器等第三方软件预览由插件渲染好的 markdown 文件。</p><p>在笔者的体验中 vim-markdown-composer 以及 markdown-preview.nvim 可以算是其中最好的两款预览插件。</p><h2 id="markdown-preview-nvim"><a href="#markdown-preview-nvim" class="headerlink" title="markdown-preview.nvim"></a>markdown-preview.nvim</h2><p>参考其<a href="https://github.com/iamcco/markdown-preview.nvim">github 主页</a>的安装配置信息，很容易搞定。</p><p>该插件的优点很明显。它支持很多内嵌语言的渲染，单文件渲染体验极佳。</p><p>这里主要强调一些问题（仅针对本文写成时存在的问题）。</p><ul><li>目前尚未提供流畅的多文件预览功能。可以通过设置打开文件时预览自动开启和关闭文件时预览自动关闭勉强实现该功能。</li></ul><blockquote><p>这里的多文件指的是当在多个 buffer 切换的时候，可以自动切换预览画面。</p></blockquote><ul><li><p>判定文件开关的机制有点问题。主要表现在一旦使用自动开启和关闭预览。你在 vim 中使用的所有浮动窗口、侧边栏都会被判定为不同形式的文件关闭（经笔者试验，大概浮动窗口不会检测到文件关闭，但退出时会认为文件又一次打开，侧边栏会）。当退出这些窗口时，会再次自动渲染。这将使你的浏览器（或标签页）不断工作在开关状态，耗费资源还容易卡住，严重打击使用体验感。</p></li><li><p>无法重新载入资源。举个例子。当你打开预览之后，新截一张图，在文件中调用，预览将无法显示该图片，需要重启预览。</p></li></ul><p>如果你无法忍受这些问题，可以使用下一个插件。</p><h2 id="vim-markdown-composer"><a href="#vim-markdown-composer" class="headerlink" title="vim-markdown-composer"></a>vim-markdown-composer</h2><p>该插件需要 rust 语言环境支持。关于如何配置 rust 环境，由于步骤非常简单，提倡自行解决。</p><p>参考其<a href="https://github.com/euclio/vim-markdown-composer">github 主页</a>的配置，使用 vim-plug 的用户可以使用以下配置安装。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">function! BuildComposer(info)  if a:info.status !&#x3D; &#39;unchanged&#39; || a:info.force    if has(&#39;nvim&#39;)      !cargo build --release --locked    else      !cargo build --release --locked --no-default-features --features json-rpc    endif  endifendfunctionPlug &#39;euclio&#x2F;vim-markdown-composer&#39;, &#123; &#39;do&#39;: function(&#39;BuildComposer&#39;) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装后使用<code>:help markdown-composer</code>可以查看其文档。主要有几个配置参数，以及插件命令。这里给出插件提供的命令。</p><pre class="line-numbers language-none"><code class="language-none">:ComposerStart              Start the preview server.:ComposerUpdate             Send the current buffer to the preview server.:ComposerOpen               Opens a new browser window containing the markdown preview.:ComposerJob                Echoes the channel that the plugin is listening on.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以自行配置快捷键。这里给出我的配置。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; markdown-composerlet g:markdown_composer_external_renderer&#x3D;&#39;pandoc -f markdown -t html&#39;let g:markdown_composer_autostart &#x3D; 0nmap &lt;silent&gt;&lt;nowait&gt;&lt;leader&gt;ms :&lt;C-u&gt;ComposerStart&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;leader&gt;mu :&lt;C-u&gt;ComposerUpdate&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;leader&gt;mo :&lt;C-u&gt;ComposerOpen&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;leader&gt;mj :&lt;C-u&gt;ComposerJob&lt;CR&gt;let g:which_key_map2.m &#x3D; &#123;      \ &#39;name&#39; : &#39;+markdown_preview&#39;,      \ &#39;s&#39; : &#39;start&#39;,      \ &#39;u&#39; : &#39;update&#39;,      \ &#39;o&#39; : &#39;open another tab&#39;,      \ &#39;j&#39; : &#39;echoes the channel that the plugin is listening on&#39;      \&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该插件多文件切换预览效果非常好。但是注意，该插件本身没有内置 latex 语言的渲染功能，其他语言就更不用说了。所以要想或者最佳体验，还需要使用外部渲染器。即上面给出配置中的第一行，使用 pandoc 渲染 markdown 文件。因此还必须安装 pandoc 软件，并确定可以在全局调用 pandoc 命令。</p><p>另有一个注意事项。假设有目录 X，内有二级目录 A 和 B。A 中存放 markdown 文件，B 中存放图片。如果在 A 目录内打开 markdown 文件，则还是会出现上一个插件新图片无法载入的问题（如果调用时使用绝对路径可能不会出现该问题）。如果在 X 目录下打开 A 中的 markdown 文件，则不会有上述问题。其他位置打开，应该都有该问题。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Vim as the Editor of Systemverilog</title>
      <link href="2021/03/23/use-vim-as-the-editor-of-systemverilog/"/>
      <url>2021/03/23/use-vim-as-the-editor-of-systemverilog/</url>
      
        <content type="html"><![CDATA[<h1 id="使用vim作为systemverilog编辑器"><a href="#使用vim作为systemverilog编辑器" class="headerlink" title="使用vim作为systemverilog编辑器"></a>使用vim作为systemverilog编辑器</h1><p>本文介绍如何使用 vim 搭建 systemverilog 编辑环境。功能包括自动补全、语法高亮、语法检查、格式化等。</p><h2 id="自动补全与语法检查"><a href="#自动补全与语法检查" class="headerlink" title="自动补全与语法检查"></a>自动补全与语法检查</h2><p>自动补全功能使用 lsp。本文选用 svls 作为 systemverilog 的语言服务器。</p><p>svls 使用 rust 语言编写，需要 rust 语言环境，使用 rust 包管理器 cargo 安装。或者可以从 snap 商店下载。</p><p>选择一款管理调用 lsp 的 vim 插件。本文选用 coc.nvim。在 coc.nvim 的配置文件中添加以下内容。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;languageserver&quot;: &#123;    &quot;svls&quot;: &#123;        &quot;command&quot;: &quot;svls&quot;,        &quot;filetypes&quot;: [&quot;systemverilog&quot;]    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>filetypes</code>不一定正确。可以新建一个.sv 文件，查看文件类型。比如，在 neovim5 中，文件类型为<code>verilog_systemverilog</code>。</p><p>选用其他插件的可以在<a href="https://github.com/dalance/svls">svls github 主页</a>找到相应配置。</p><p>svls 的配置文件为<code>.svls.toml</code>，该文件放在项目的根目录。配置文件的编写方式非常简单。</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[verilog]include_paths &#x3D; [&quot;src&#x2F;header&quot;][option]linter &#x3D; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将以上<code>include_paths</code>的值修改为要编写的.sv 文件所在目录即可。</p><p>至此，完成自动补全与语法检查功能的配置。</p><p>关于语法检查功能，可以同时使用 ale 插件。该插件可以通过 iverilog 编译器提供错误信息，两者错误信息并不完全重合。</p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>systemverilog 的格式化需要<a href="https://github.com/google/verible">verible</a>的支持。verible 为 google 为 systemverilog 开发的一套工具集，其中包含了格式化工具。</p><p>verible 提供了.deb 和.rpm 的二进制包，包管理系统兼容该两种打包方式的用户可以直接安装。</p><p>其他用户需要自行编译，从 github 上拉取源码后，在源码目录使用<code>bazel build -c opt //...</code>编译。注意需要支持 C++11 的 gcc 编译器（clang 暂时无法编译成功）。</p><p>编译完成后，使用<code>bazel run -c opt :install -- path</code>安装到指定位置。如果安装位置需要 root 权限，则使用<code>bazel run -c opt :install -- -s path</code>，务必注意不能使用 sudo。</p><p>在 vim 中调用格式化工具的插件选用 neoformat。该插件的安装过程不再赘述。调用格式化程序的配置方式在其文档中有详细说明，这里只给出一个例子。</p><p>环境：neovim、linux</p><p>创建<code>~/.local/share/nvim/site/autoload/neoformat/formatters</code>目录。编写<code>verilog_systemverilog.vim</code>，写入以下内容</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">function! neoformat#formatters#verilog_systemverilog#enabled() abort    return [&#39;verible_format&#39;]endfunctionfunction! neoformat#formatters#verilog_systemverilog#verible_format() abort    return &#123;        \ &#39;exe&#39;: &#39;&#x2F;opt&#x2F;verible&#x2F;verilog_format&#39;,        \ &#125;endfunction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意文件名称是 vim 中 systemverilog 的文件类型。如果不是<code>verilog_systemverilog</code>则需要替换文件名及文件中所有出现<code>verilog_systemverilog</code>的地方。<code>exe</code>需要可执行，即如果格式化程序所在目录不在<code>$PATH</code>中，需要填写其绝对路径。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上方案对比 vscode 以及各类 IDE，如 vivado 等，在编辑体验上可以算是完胜。</p><p>vscode 中虽然有基于 svls 的插件，以及语言格式化插件，但整体补全能力上比不上高度扩展的 vim。并且仅仅依靠 svls 的错误检查，并不能找出所有错误（语法错误，而非逻辑错误），但 vim 可以再叠加其他的检测，如 ale。</p><p>各类 IDE 虽然功能非常强大，甚至可能只需使用图形界面配置就能自动生成 systemverilog 文件，但是在编辑体验上远远比不上前两者。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Debugging Scheme</title>
      <link href="2020/10/20/vim-debugging-scheme/"/>
      <url>2020/10/20/vim-debugging-scheme/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-调试方案"><a href="#vim-调试方案" class="headerlink" title="vim 调试方案"></a>vim 调试方案</h1><p>本文介绍在 vim 中使用 vimspector 插件扩展 IDE 式调试功能，获取极致体验。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>为什么需要扩展调试功能？</li></ul><p>虽然传统上与 vim 更匹配的调试方案是在命令行中使用 gdb、lldb 等调试器，但这就不得不暂时离开 vim。虽然有诸如 tmux、内置 terminal 等工具可以使得命令行调试变得更加方便，但具有 ui 界面，且就在 vim 中的调试无疑会更加直观。</p><ul><li>vimspector 插件的调试能力</li></ul><p>可以查看其<a href="https://github.com/puremourning/vimspector">github 主页</a>。包括可调试的语言、调试输出的信息、调试的主要界面等等均可以看到。可以说 vimspector 是一个相当专业的调试插件。</p><h2 id="vimspector-安装"><a href="#vimspector-安装" class="headerlink" title="vimspector 安装"></a>vimspector 安装</h2><p>可以参考官方提供的安装方式，也可以按照以下笔者推荐的方式安装。</p><p>首先，该插件需要被安装在<code>pack/x/opt</code>的目录下，如果想使用插件管理器安装，必须将安装目录修改为<code>xxx/pack/x/opt</code>。其中<code>xxx</code>是前一段的路径，可以不止一级，可以自定义，<code>x</code>是一级目录，可以为任意名称。然后在 vim 配置文件中，声明<code>set packpath= the_path_to_your_pack_directory</code>，只需要到<code>pack</code>的前一级目录即可。然后直接使用包管理器安装即可。至此，插件本身安装完毕。</p><h2 id="vimspector-配置"><a href="#vimspector-配置" class="headerlink" title="vimspector 配置"></a>vimspector 配置</h2><p>使用<code>:VimspectorInstall</code>来安装调试需要的适配器，如<code>:VimspectorInstall --enable-c</code>，具体参数可以在其主页找到。使用<code>:VimspectorUpdate</code>更新所有适配器。</p><p>安装好所需适配器之后，可以继续配置快捷键。可以使用官方提供的两套快捷键，也可以自定义。</p><p>使用官方快捷键可以设置<code>let g:vimspector_enable_mappings = &#39;HUMAN&#39;</code>或者<code>let g:vimspector_enable_mappings = &#39;VISUAL_STUDIO&#39;</code>。</p><p>如果要自定义，以下配置仅供参考。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dn &lt;Plug&gt;VimspectorStepOvernmap &lt;A-n&gt; &lt;Plug&gt;VimspectorStepOvernmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;db &lt;Plug&gt;VimspectorToggleBreakpointnmap &lt;A-b&gt; &lt;Plug&gt;VimspectorToggleBreakpointnmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;ds &lt;Plug&gt;VimspectorContinuenmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dr &lt;Plug&gt;VimspectorRestartnmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dp &lt;Plug&gt;VimspectorPausenmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dt &lt;Plug&gt;VimspectorStopnmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;df &lt;Plug&gt;VimspectorAddFunctionBreakpointnmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dc &lt;Plug&gt;VimspectorToggleConditionalBreakpointnmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;do &lt;Plug&gt;VimspectorStepOutnmap &lt;A-o&gt; &lt;Plug&gt;VimspectorStepOutnmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;di &lt;Plug&gt;VimspectorStepIntonmap &lt;A-i&gt; &lt;Plug&gt;VimspectorStepIntonmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dq &lt;Plug&gt;VimspectorReset&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dlc &lt;Plug&gt;VimspectorShowOutput Console&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dld &lt;Plug&gt;VimspectorShowOutput stderr&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dlo &lt;Plug&gt;VimspectorShowOutput Vimspector-out&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dle &lt;Plug&gt;VimspectorShowOutput Vimspector-err&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dls &lt;Plug&gt;VimspectorShowOutput server&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dlt &lt;Plug&gt;VimspectorShowOutput Telemetry&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;de :&lt;C-u&gt;VimspectorEval&lt;space&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dw :&lt;C-u&gt;VimspectorWatch&lt;space&gt;nmap &lt;A-w&gt; :&lt;C-u&gt;VimspectorWatch&lt;space&gt;let g:which_key_map1.d &#x3D; &#123;444\ &#39;name&#39; : &#39;+debug&#39;,444\ &#39;e&#39; : &#39;eval&#39;,444\ &#39;w&#39; : &#39;variable watch&#39;,444\ &#39;s&#39; : &#39;start or continue&#39;,444\ &#39;t&#39; : &#39;stop&#39;,444\ &#39;r&#39; : &#39;restart&#39;,444\ &#39;p&#39; : &#39;pause&#39;,444\ &#39;b&#39; : &#39;set breakpoint&#39;,444\ &#39;c&#39; : &#39;set condition breakpoint&#39;,444\ &#39;f&#39; : &#39;add function breakpoint&#39;,444\ &#39;n&#39; : &#39;next&#39;,444\ &#39;i&#39; : &#39;step in&#39;,444\ &#39;o&#39; : &#39;step out&#39;,444\ &#39;q&#39; : &#39;quit&#39;,444\ &#39;l&#39; :  &#123;444\ &#39;name&#39; : &#39;+switch_output&#39;,444\ &#39;c&#39; : &#39;Console&#39;,444\ &#39;d&#39; : &#39;stderr&#39;,444\ &#39;o&#39; : &#39;Vimspector-out&#39;,444\ &#39;e&#39; : &#39;Vimspector-err&#39;,444\ &#39;s&#39; : &#39;server&#39;,444\ &#39;t&#39; : &#39;Telemetry&#39;,444\&#125;,444\&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 vimspector 的一些功能暂不支持 neovim，这一点在主页上有说明。不过并不影响使用。以上配置中这些部分就是在 neovim 中用于切换窗口的命令和快捷键。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dlc &lt;Plug&gt;VimspectorShowOutput Console&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dld &lt;Plug&gt;VimspectorShowOutput stderr&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dlo &lt;Plug&gt;VimspectorShowOutput Vimspector-out&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dle &lt;Plug&gt;VimspectorShowOutput Vimspector-err&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dls &lt;Plug&gt;VimspectorShowOutput server&lt;CR&gt;nmap &lt;silent&gt;&lt;nowait&gt;&lt;space&gt;dlt &lt;Plug&gt;VimspectorShowOutput Telemetry&lt;CR&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此为止，该插件仍不可以使用，还差最后一步。</p><p>该插件本身的配置文件有两种，一是<code>.gadgets.json</code>，二是<code>.vimspector.json</code>。前面安装适配器的过程中已经自动产生了不少配置。关于这些配置文件的具体内容和关系可以自行研究，这里只介绍如何完成最后一步配置。</p><p>在工程项目目录下新建<code>.vimspector.json</code>文件。copy 插件主页上给出的示例配置。</p><p>以 rust 语言为例，给出的示例配置为</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;configurations&quot;: &#123;    &quot;launch&quot;: &#123;      &quot;adapter&quot;: &quot;CodeLLDB&quot;,      &quot;configuration&quot;: &#123;        &quot;request&quot;: &quot;launch&quot;,        &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;target&#x2F;debug&#x2F;vimspector_test&quot;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要修改<code>program</code>的值为可执行文件路径即可。至此，所有配置均已完成。</p><p>最后注意一点，这个配置下插件并不会自动调用编译器编译工程。因此还需要手动编译生成可执行文件。</p><p>另外，该插件也可以监听端口，调试进程，有需要的可以自行研究。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Shortcut Key Management</title>
      <link href="2020/10/19/vim-shortcut-key-management/"/>
      <url>2020/10/19/vim-shortcut-key-management/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-快捷键管理"><a href="#vim-快捷键管理" class="headerlink" title="vim 快捷键管理"></a>vim 快捷键管理</h1><p>本文主要介绍如何使用<code>vim-which-key</code>管理 vim 快捷键。</p><h2 id="快捷键管理"><a href="#快捷键管理" class="headerlink" title="快捷键管理"></a>快捷键管理</h2><ul><li>什么是快捷键管理？</li></ul><p>这里的所谓快捷键管理，不是指修改快捷键，而是快捷键提示。</p><ul><li>为什么需要快捷键管理？</li></ul><p>当你比较熟悉 vim 之后，就会使用各种快捷键。随着 vim 的不断扩展，需要为各种插件设置快捷键。从简单的<code>ctrl</code>、<code>alt</code>、<code>shift</code>组合到<code>&lt;space&gt;</code>、<code>&lt;leader&gt;</code>的使用，你终将配置连自己都数不清的快捷键。幸运的是， vim 的一个好处在于，它可以设置无数快捷键。但不幸的是，人脑不可能记住那么多快捷键。</p><p>快捷键管理的好处在于，只要你有一个印象，甚至哪怕是一点印象都没有，你终将在它的提示中找到你要的那个键。</p><h2 id="vim-which-key"><a href="#vim-which-key" class="headerlink" title="vim-which-key"></a>vim-which-key</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="./vim-shortcut-key-management/1.png" alt="效果图"></p><p>以上为在普通模式下按下空格键时给出的提示。</p><h3 id="vim-which-key-安装"><a href="#vim-which-key-安装" class="headerlink" title="vim-which-key 安装"></a>vim-which-key 安装</h3><p>访问其<a href="https://github.com/liuchengxu/vim-which-key">github 主页</a></p><p>直接用插件管理器安装即可。</p><h3 id="vim-which-key-配置"><a href="#vim-which-key-配置" class="headerlink" title="vim-which-key 配置"></a>vim-which-key 配置</h3><p>首先给出我的部分配置，分析在配置中。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; 定义字典变量，这将是后续为具体快捷键定义提示的基础。注意这些行必须在所有具体定义之前，否则会报错，提示变量未定义。let g:which_key_map1 &#x3D;  &#123;&#125;let g:which_key_map2 &#x3D;  &#123;&#125;&quot; 设置leader与localleader键位，也可以不设置，明确是哪个就好。let g:mapleader &#x3D; &quot;\\&quot;let g:maplocalleader &#x3D; &quot;\&lt;Space&gt;&quot;&quot; 为具体的按键绑定字典变量。这样当按下该键一段时间后，会自动展开该键下的提示。call which_key#register(&#39;&lt;Space&gt;&#39;, &quot;g:which_key_map1&quot;)call which_key#register(&#39;\&#39;, &quot;g:which_key_map2&quot;)&quot; 定义vim-which-key自身的快捷键，使得插件在该键按下的时候响应。nnoremap &lt;silent&gt; &lt;localleader&gt; :&lt;c-u&gt;WhichKey &#39;&lt;Space&gt;&#39;&lt;CR&gt;vnoremap &lt;silent&gt; &lt;localleader&gt; :&lt;c-u&gt;WhichKeyVisual &#39;&lt;Space&gt;&#39;&lt;CR&gt;nnoremap &lt;silent&gt; &lt;leader&gt; :&lt;c-u&gt;WhichKey &#39;\&#39;&lt;CR&gt;vnoremap &lt;silent&gt; &lt;leader&gt; :&lt;c-u&gt;WhichKeyVisual &#39;\&#39;&lt;CR&gt;&quot; 隐藏提供的提供的statusline的主题（该主题不灵活）。也可以不设置。autocmd! FileType which_keyautocmd  FileType which_key set laststatus&#x3D;0 noshowmode noruler444\| autocmd BufLeave &lt;buffer&gt; set laststatus&#x3D;2 showmode ruler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，我们可以为具体快捷键配置提示信息了。</p><h3 id="具体提示信息配置"><a href="#具体提示信息配置" class="headerlink" title="具体提示信息配置"></a>具体提示信息配置</h3><p>默认情况下，即使不进行配置，vim-which-key 也会自动搜集所有插件的快捷键，但是仅显示快捷键绑定的命令，提示效果较差。</p><p>为获得更好的提示体验，最好手动配置提示信息。提供以下几个案例，参考一下即可。</p><ul><li>案例一</li></ul><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; coc-translator&quot; popupnmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;tp  &lt;Plug&gt;(coc-translator-p)vmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;tp  &lt;Plug&gt;(coc-translator-pv)&quot; echonmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;te  &lt;Plug&gt;(coc-translator-e)vmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;te  &lt;Plug&gt;(coc-translator-ev)&quot; replacenmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;tr  &lt;Plug&gt;(coc-translator-r)vmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;tr  &lt;Plug&gt;(coc-translator-rv)&quot; 以上为其余插件的快捷键配置。以下为vim-which-key的配置。let g:which_key_map1.t &#x3D; &#123;444\ &#39;name&#39; : &#39;+translate&#39;,444\ &#39;p&#39; : &#39;popup&#39;,444\ &#39;e&#39; : &#39;echo&#39;,444\ &#39;r&#39; : &#39;replace&#39;,444\ &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>案例二</li></ul><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">let g:which_key_map1.l &#x3D; &#39;move to line&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>案例三</li></ul><p>注意该案例中<code>l</code>处又是一层嵌套。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">let g:which_key_map1.d &#x3D; &#123;444\ &#39;name&#39; : &#39;+debug&#39;,444\ &#39;e&#39; : &#39;eval&#39;,444\ &#39;w&#39; : &#39;variable watch&#39;,444\ &#39;s&#39; : &#39;start or continue&#39;,444\ &#39;t&#39; : &#39;stop&#39;,444\ &#39;r&#39; : &#39;restart&#39;,444\ &#39;p&#39; : &#39;pause&#39;,444\ &#39;b&#39; : &#39;set breakpoint&#39;,444\ &#39;c&#39; : &#39;set condition breakpoint&#39;,444\ &#39;f&#39; : &#39;add function breakpoint&#39;,444\ &#39;n&#39; : &#39;next&#39;,444\ &#39;i&#39; : &#39;step in&#39;,444\ &#39;o&#39; : &#39;step out&#39;,444\ &#39;q&#39; : &#39;quit&#39;,444\ &#39;l&#39; :  &#123;444\ &#39;name&#39; : &#39;+switch_output&#39;,444\ &#39;c&#39; : &#39;Console&#39;,444\ &#39;d&#39; : &#39;stderr&#39;,444\ &#39;o&#39; : &#39;Vimspector-out&#39;,444\ &#39;e&#39; : &#39;Vimspector-err&#39;,444\ &#39;s&#39; : &#39;server&#39;,444\ &#39;t&#39; : &#39;Telemetry&#39;,444\&#125;,444\&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以忽略部分按键的提示，将其提示设置为<code>which_key_ignore</code>即可。比如</p><pre class=" language-vim"><code class="language-vim"><span class="token keyword">let</span> g<span class="token punctuation">:</span>which_key_map2<span class="token punctuation">[</span><span class="token string">'\'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'which_key_ignore'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>which_key_map2<span class="token punctuation">[</span><span class="token string">'\A'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'which_key_ignore'</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Plugin Management</title>
      <link href="2020/10/19/vim-plugin-management/"/>
      <url>2020/10/19/vim-plugin-management/</url>
      
        <content type="html"><![CDATA[<h1 id="vim插件管理"><a href="#vim插件管理" class="headerlink" title="vim插件管理"></a>vim插件管理</h1><p>本文介绍vim插件管理器。主要推荐vim-plug。如果想要更多扩展功能，可以尝试dein.vim。</p><h2 id="vim插件管理器"><a href="#vim插件管理器" class="headerlink" title="vim插件管理器"></a>vim插件管理器</h2><ul><li>为什么需要插件管理器？</li></ul><p>随着你对vim的不断扩展，为vim安装的插件将会越来越多。如果没有插件管理器，一方面，你可能无法高效地更新插件，另一方面，一些插件可能必须手动唤醒或者vim启动时启用的插件过多，导致速度大大降低。</p><ul><li>vim插件管理器能做什么？</li></ul><p>提供统一的插件安装、升级、移除指令。调配各插件的启动时机，提高运行vim效率。</p><h2 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h2><p>vim-plug是继vundle后新一代的插件管理器。支持并行安装插件、支持外部管理的插件、支持按需加载等等功能。</p><h3 id="vim-plug安装"><a href="#vim-plug安装" class="headerlink" title="vim-plug安装"></a>vim-plug安装</h3><p>访问vim-plug <a href="https://github.com/junegunn/vim-plug">github 主页</a>。下载<code>plug.vim</code>，放入<code>~/.vim/autoload/</code>或者<code>~/.local/share/nvim/site/autoload/</code>目录下。vim启动时会自动加载该目录下的插件。</p><p>对于windows和macos可以自行查看说明。</p><h3 id="vim-plug配置"><a href="#vim-plug配置" class="headerlink" title="vim-plug配置"></a>vim-plug配置</h3><pre class="line-numbers language-none"><code class="language-none">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)&quot; 上一行中括号内的是插件存放的目录Plug &#39;junegunn&#x2F;vim-easy-align&#39;&quot; 上一行中引号内的是插件在github上的地址，前面是作者用户名，后面是插件名称call plug#end()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="vim-plug使用"><a href="#vim-plug使用" class="headerlink" title="vim-plug使用"></a>vim-plug使用</h3><p>配置好插件之后，使用<code>:PlugInstall</code>安装插件。使用<code>PlugUpdate</code>更新所有插件，使用<code>PlugClean</code>清理不在配置内的插件。更多命令可以自行插件<code>README.md</code>。</p><p>关于按需加载，以及各种功能配置，由于vim-plug已经非常流行，一般不是很老的插件都会给出其<code>vim-plug</code>的配置。当然也可以自己根据文档研究。</p><h3 id="dein-vim"><a href="#dein-vim" class="headerlink" title="dein.vim"></a>dein.vim</h3><p>这是一个具有更强大的扩展性以及更加快速的插件管理器，但由于配置麻烦的多，且只有少数插件会给出其<code>dein.vim</code>的配置，因此笔者个人建议在插件未达到好几百的情况下，使用<code>vim-plug</code>足以。</p><p>如果你非常想要尝试，也建议搭配<code>dein-ui.vim</code>使用，可以大大降低配置难度，并且提供类似<code>vim-plug</code>的ui界面。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Tagbar</title>
      <link href="2020/10/19/vim-tagbar/"/>
      <url>2020/10/19/vim-tagbar/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-tagbar"><a href="#vim-tagbar" class="headerlink" title="vim tagbar"></a>vim tagbar</h1><p>本文介绍 vim tagbar 插件替代品，获取更好的 tags 显示体验。</p><h2 id="vista-vim-介绍"><a href="#vista-vim-介绍" class="headerlink" title="vista.vim 介绍"></a>vista.vim 介绍</h2><p>vista.vim 插件相比于 tagbar 插件的优势主要在于异步以及 lsp 支持。lsp 支持意味着有可能为各种语言提取 tags。</p><p>vista.vim 显示 tags 的方式来自于 universal-ctags、ale、vim-lsp、coc.nvim、LanguageClient-neovim、vim-lsc、nvim-lspconfig 等。提取 tags 的方式来自于 fzf、skim、vim-clap 等。这就意味着该插件需要以上插件或者包的支持。这里，笔者推荐第一部分可以采用 universal-ctags、或 coc.nvim 或 ale，第二部分采用 vim-clap。</p><h2 id="vista-vim-安装配置"><a href="#vista-vim-安装配置" class="headerlink" title="vista.vim 安装配置"></a>vista.vim 安装配置</h2><p>vista.vim 的安装很简单，参考其<a href="https://github.com/liuchengxu/vista.vim">github 主页</a>即可。</p><p>配置 vista.vim，可以参考我的配置。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; vista.vimfunction! NearestMethodOrFunction() abort4return get(b:, &#39;vista_nearest_method_or_function&#39;, &#39;&#39;)endfunctionset statusline+&#x3D;%&#123;NearestMethodOrFunction()&#125;&quot; By default vista.vim never run if you don&#39;t call it explicitly.&quot;&quot; If you want to show the nearest function in your statusline automatically,&quot; you can add the following line to your vimrcautocmd VimEnter * call vista#RunForNearestMethodOrFunction()let g:vista_icon_indent &#x3D; [&quot;╰─▸ &quot;, &quot;├─▸ &quot;]let g:vista_default_executive &#x3D; &#39;ctags&#39;let g:vista_executive_for &#x3D; &#123;444\ &#39;cpp&#39;: &#39;coc&#39;,444\ &#39;php&#39;: &#39;coc&#39;,444\ &#125;let g:vista_ctags_cmd &#x3D; &#123;444\ &#39;haskell&#39;: &#39;hasktags -x -o - -c&#39;,444\ &#125;let g:vista_fzf_preview &#x3D; [&#39;right:50%&#39;]let g:vista#renderer#enable_icon &#x3D; 1let g:vista#renderer#icons &#x3D; &#123;444\   &quot;function&quot;: &quot;\uf794&quot;,444\   &quot;variable&quot;: &quot;\uf71b&quot;,444\  &#125;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;m :&lt;C-u&gt;Vista!!&lt;cr&gt;let g:which_key_map1.m &#x3D; &#39;open the file tagbar&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中需要注意的有以下几行</p><pre class="line-numbers language-none"><code class="language-none">let g:vista_default_executive &#x3D; &#39;ctags&#39;let g:vista_executive_for &#x3D; &#123;444\ &#39;cpp&#39;: &#39;coc&#39;,444\ &#39;php&#39;: &#39;coc&#39;,444\ &#125;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;m :&lt;C-u&gt;Vista!!&lt;cr&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一行表示使用的默认显示 tags 工具，其实指的是提取 tags 的工具。不同工具的显示方式不同。笔者在这里使用的是<code>universal-ctags</code>，因此设置为 ctags。其余可选项可以参考其 github 主页。</p><p>第二行是为特殊文件类型配置特殊工具。</p><p>第三行是快捷键设置，只需要为<code>:Vista!!</code>命令配置快捷键即可。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim File Tree</title>
      <link href="2020/10/19/vim-file-tree/"/>
      <url>2020/10/19/vim-file-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim-文件树"><a href="#Vim-文件树" class="headerlink" title="Vim 文件树"></a>Vim 文件树</h1><p>本文介绍 nerdtree 替代品，全新 vim filetree 解决方案。</p><h2 id="coc-explorer"><a href="#coc-explorer" class="headerlink" title="coc-explorer"></a>coc-explorer</h2><p>coc-explorer 是一个 coc 插件。运行于 coc.nvim 提供的插件平台上。相比于nerdtree，不说性能问题，直观上就将提供更多的文件信息以及更流畅的体验。同时也可以配置icons。</p><p>关于coc-explorer的效果图及具体配置，请见其<a href="https://github.com/weirongxu/coc-explorer">github主页</a>。</p><p>嫌麻烦的话，直接<code>CocInstall coc-explorer</code>。再设置一下快捷键等就可以直接使用了。以下附上我的配置。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; coc-explorernnoremap &lt;leader&gt;p :CocCommand explorer&lt;CR&gt;let which_key_map2.p &#x3D;&#39;file tree&#39;function! s:coc_list_current_dir(args)4let node_info &#x3D; CocAction(&#39;runCommand&#39;, &#39;explorer.getNodeInfo&#39;, 0)4execute &#39;cd &#39; . fnamemodify(node_info[&#39;fullpath&#39;], &#39;:h&#39;)4execute &#39;CocList &#39; . a:argsendfunctionfunction! s:init_explorer(bufnr)4call setbufvar(a:bufnr, &#39;&amp;winblend&#39;, 50)endfunctionfunction! s:enter_explorer()4if !exists(&#39;b:has_enter_coc_explorer&#39;) &amp;&amp; &amp;filetype &#x3D;&#x3D; &#39;coc-explorer&#39;44&quot; more mappings44nmap &lt;buffer&gt; &lt;Leader&gt;fg :call &lt;SID&gt;coc_list_current_dir(&#39;-I grep&#39;)&lt;CR&gt;44nmap &lt;buffer&gt; &lt;Leader&gt;fG :call &lt;SID&gt;coc_list_current_dir(&#39;-I grep -regex&#39;)&lt;CR&gt;44nmap &lt;buffer&gt; &lt;C-p&gt; :call &lt;SID&gt;coc_list_current_dir(&#39;files&#39;)&lt;CR&gt;44let b:has_enter_coc_explorer &#x3D; v:true4endif4&quot; statusline4setl statusline&#x3D;coc-explorerendfunctionaugroup CocExplorerCustom4autocmd!4autocmd BufEnter call &lt;SID&gt;enter_explorer()augroup END&quot; hook for explorer window initializedfunction! CocExplorerInited(filetype, bufnr)4&quot; transparent4call setbufvar(a:bufnr, &#39;&amp;winblend&#39;, 10)endfunction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Automatic Completion</title>
      <link href="2020/10/19/vim-automatic-completion/"/>
      <url>2020/10/19/vim-automatic-completion/</url>
      
        <content type="html"><![CDATA[<p>本文介绍 vim 自动补全方案。主要采用更强大的 coc.nvim 插件来替代 YCM。</p><h1 id="vim-自动补全"><a href="#vim-自动补全" class="headerlink" title="vim 自动补全"></a>vim 自动补全</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自动补全对于任何一个试图取代 IDE 的编辑器的重要性不言而喻。想要将 vim 打造为最契合自己的 IDE，无论如何都不能少了强大的自动补全功能。</p><h2 id="coc-nvim-介绍"><a href="#coc-nvim-介绍" class="headerlink" title="coc.nvim 介绍"></a>coc.nvim 介绍</h2><p>coc.nvim 是针对 neovim 开发的的功能非常强大，完全可以替代 YCM，带来更加优越的补全体验。包括语义补全、片段补全、定义跳转、文档查阅、静态检查等等。</p><p>同时 coc.nvim 也是一个全新的插件平台，除了其原生插件外，理论上也支持所有纯 JS 实现的 vscode 插件。拥有 coc.nvim，就拥有了一个异步插件平台。</p><h2 id="coc-nvim-安装"><a href="#coc-nvim-安装" class="headerlink" title="coc.nvim 安装"></a>coc.nvim 安装</h2><p>coc.nvim 需要<code>nodejs</code>支持。安装<code>nodejs</code>后，用插件管理器安装 coc.nvim 即可。具体可参考其<a href="https://github.com/neoclide/coc.nvim">github 主页</a>。</p><h2 id="使用-coc-nvim-进行补全"><a href="#使用-coc-nvim-进行补全" class="headerlink" title="使用 coc.nvim 进行补全"></a>使用 coc.nvim 进行补全</h2><p>coc.nvim 的补全可以采用安装插件或者配置 lsp 实现。</p><h3 id="语义补全及静态检查"><a href="#语义补全及静态检查" class="headerlink" title="语义补全及静态检查"></a>语义补全及静态检查</h3><p>以 rust 语言为例，可以直接使用<code>:CocInstall</code>安装<code>coc-rust-analyzer</code>插件（会自动安装<code>rust-analyzer</code>）。也可以在安装<code>rust-analyzer</code>后在 coc.nvim 的配置文件中配置。使用<code>:CocConfig</code>打开配置文件，写入</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;languageserver&quot;: &#123;    &quot;rust&quot;: &#123;      &quot;command&quot;: &quot;rust-analyzer&quot;,      &quot;filetypes&quot;: [&quot;rust&quot;],      &quot;rootPatterns&quot;: [&quot;Cargo.toml&quot;]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<code>command</code>必须保证可用。</p><p>关于coc插件以及lsp配置的具体内容可以参考<a href="https://github.com/neoclide/coc.nvim/wiki">coc.nvim wiki</a>。</p><p>到此，rust语言的自动补全已经配置完成，静态检查也同步配置完成。但仅仅如此还不可以使用。coc.nvim的自动配置在项目工程中才能起作用。如单独编写一个<code>main.rs</code>，则不会有语义提示。必须以<code>cargo new demo</code>新建一个工程，插件检测到<code>Cargo.toml</code>后才会启动语义的自动补全。当然也有可以直接在单文件中提示的特例，如markdown语言，本身就不存在工程的概念。</p><h3 id="片段补全"><a href="#片段补全" class="headerlink" title="片段补全"></a>片段补全</h3><p>安装<code>coc-actions</code>插件。</p><p>再在<code>coc-snippets</code>、<code>coc-ultisnips</code>中选择一个或全选即可。注意需要同步安装<code>honza/vim-snippets</code>、<code>SirVer/ultisnips</code>。</p><h3 id="自定义补全源"><a href="#自定义补全源" class="headerlink" title="自定义补全源"></a>自定义补全源</h3><p>coc.nvim默认的补全源来自当前打开的所有buffer、插件或lsp等。此外也可以自定义补全源。具体可参见<a href="https://github.com/neoclide/coc.nvim/wiki/Create-custom-source">coc.nvim wiki</a></p><p>下面以补全markdown中的latex语法为例，展示如何自定义补全源。</p><p>创建目录<code>~/.config/nvim/autoload/coc/source</code>。这里以linux系统为例，其他系统的位置可以自行参考wiki。</p><p>创建<code>latex.vim</code>，写入</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">function! coc#source#latex#init() abort4return &#123;4444\&#39;triggerCharacters&#39;: [&#39;\&#39;],4444\&#39;filetypes&#39; : [&#39;markdown&#39;],4444\&#125;endfunctionfunction! coc#source#latex#complete(opt, cb) abort4let items &#x3D; [&#39;kappa&#39;, &#39;theta&#39;, &#39;dot&#123;&#125;&#39;, &#39;ddot&#123;&#125;&#39;, &#39;bar&#123;&#125;&#39;, &#39;hat&#123;&#125;&#39;, &#39;exp&#39;, &#39;sin&#39;, &#39;cos&#39;, &#39;tan&#39;, &#39;sec&#39;, &#39;csc&#39;, &#39;vec&#123;&#125;&#39;, &#39;cot&#39;, &#39;arcsin&#39;, &#39;arccos&#39;, &#39;arctan&#39;, &#39;sinh&#39;, &#39;cosh&#39;, &#39;tanh&#39;, &#39;coth&#39;, &#39;sh&#39;, &#39;ch&#39;, &#39;th&#39;, &#39;max&#39;, &#39;min&#39;, &#39;partial&#39;, &#39;nabla&#39;, &#39;prime&#39;, &#39;backprime&#39;, &#39;infty&#39;, &#39;eth&#39;, &#39;hbar&#39;, &#39;sqrt&#123;&#125;&#39;, &#39;sqrt[]&#123;&#125;&#39;, &#39;pm&#39;, &#39;mp&#39;, &#39;times&#39;, &#39;div&#39;, &#39;cdot&#39;, &#39;odot&#39;, &#39;bigodot&#39; , &#39;&#123; \&#125;&#39;, &#39;in&#39;, &#39;not&#39;, &#39;ni&#39;, &#39;cap&#39;, &#39;Cap&#39;, &#39;bigcap&#39;, &#39;cup&#39;, &#39;Cup&#39;, &#39;bigcup&#39;, &#39;subset&#39;, &#39;supset&#39;, &#39;supseteq&#39;, &#39;subseteq&#39;, &#39;subseteqq&#39;, &#39;supseteqq&#39;, &#39;subsetneq&#39;, &#39;supsetneq&#39;, &#39;supsetneqq&#39;, &#39;subsetneqq&#39;, &#39;sim&#39;, &#39;approx&#39;, &#39;leq&#39;, &#39;geq&#39;, &#39;parallel&#39;, &#39;nparallel&#39;, &#39;perp&#39;, &#39;angle&#39;, &#39;Box&#39;, &#39;bigtriangleup&#39;, &#39;bigtriangledown&#39;, &#39;forall&#39;, &#39;therefore&#39;, &#39;because&#39;, &#39;overline&#123;&#125;&#39;, &#39;Rightarrow&#39;, &#39;Leftarrow&#39;, &#39;rightarrow&#39;, &#39;leftarrow&#39;, &#39;leftrightarrow&#39;, &#39;nRightarrow&#39;, &#39;nLeftarrow&#39;, &#39;nleftarrow&#39;, &#39;nrightarrow&#39;, &#39;nleftrightarrow&#39;, &#39;overleftarrow&#123;&#125;&#39;, &#39;overrightarrow&#123;&#125;&#39;, &#39;overset&#123;&#125;&#39;, &#39;underline&#123;&#125;&#39;, &#39;sum&#39;, &#39;prod&#39;, &#39;lim&#39;, &#39;limits&#39;, &#39;int&#39;, &#39;iint&#39;, &#39;oint&#39;, &#39;iiint&#39;, &#39;frac&#123;&#125;&#123;&#125;&#39;, &#39;tfrac&#123;&#125;&#123;&#125;&#39;, &#39;dfrac&#123;&#125;&#123;&#125;&#39;, &#39;\begin&#123;matrix&#125;\end&#123;matrix&#125;&#39;, &#39;\begin&#123;vmatrix&#125;\end&#123;vmatrix&#125;&#39;, &#39;\begin&#123;bmatrix&#125;\end&#123;bmatrix&#125;&#39;, &#39;\begin&#123;Bmatrix&#125;\end&#123;Bmatrix&#125;&#39;, &#39;\begin&#123;pmatrix&#125;\end&#123;pmatrix&#125;&#39;,&#39;\begin&#123;cases&#125;\end&#123;cases&#125;&#39;, &#39;\begin&#123;aligned&#125;\end&#123;aligned&#125;&#39;, &#39;\begin&#123;array&#125;\end&#123;array&#125;&#39;, &#39;alpha&#39;, &#39;psi&#39;, &#39;Delta&#39;, &#39;delta&#39;, &#39;beta&#39;, &#39;lambda&#39;, &#39;rho&#39;, &#39;varepsilon&#39;, &#39;Gamma&#39;, &#39;chi&#39;, &#39;mu&#39;, &#39;sigma&#39;, &#39;Lambda&#39;, &#39;tau&#39;, &#39;varphi&#39;, &#39;varPhi&#39;, &#39;phi&#39;, &#39;Phi&#39;, &#39;eta&#39;, &#39;omega&#39;, &#39;varrho&#39;, &#39;Pi&#39;, &#39;pi&#39;, &#39;gamma&#39;, &#39;xi&#39;, &#39;Psi&#39;, &#39;Sigma&#39;, &#39;varnothing&#39;, &#39;iiiint&#39;]4call a:cb(items)endfunction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单分析一下。配置的主体框架按照wiki给出的例子照猫画虎即可。其中<code>triggerCharacters</code>表示触发字符，意思就是说当输入该字符时启动补全。<code>filetypes</code>表示该补全源作用的文件类型。更多选项参见wiki。</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>coc.nvim提供的其他功能还有很多，包括定义跳转、文档查询等等。感兴趣的可以自行研究。以下附上我的coc.nvim配置。仅供参考。其中<code>vim-which-key</code>的部分如果没有安装该插件就不必配置。</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">&quot; coc.nviminoremap &lt;expr&gt; &lt;C-j&gt; pumvisible() ? &quot;\&lt;C-n&gt;&quot; : &quot;\&lt;C-j&gt;&quot;inoremap &lt;expr&gt; &lt;C-k&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-k&gt;&quot;inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;inoremap &lt;silent&gt;&lt;expr&gt; &lt;cr&gt; pumvisible() ? coc#_select_confirm() : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;inoremap &lt;silent&gt;&lt;expr&gt; &lt;cr&gt; pumvisible() ? coc#_select_confirm() : &quot;\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;&#x3D;coc#on_enter()\&lt;CR&gt;&quot;autocmd! CompleteDone * if pumvisible() &#x3D;&#x3D; 0 | pclose | endif&quot; Some servers have issues with backup files, see #649.set nobackupset nowritebackup&quot; Give more space for displaying messages.set cmdheight&#x3D;2&quot; Having longer updatetime (default is 4000 ms &#x3D; 4 s) leads to noticeable&quot; delays and poor user experience.set updatetime&#x3D;300&quot; Don&#39;t pass messages to |ins-completion-menu|.set shortmess+&#x3D;c&quot; Always show the signcolumn, otherwise it would shift the text each time&quot; diagnostics appear&#x2F;become resolved.if has(&quot;patch-8.1.1564&quot;)4&quot; Recently vim can merge signcolumn and number column into one4set signcolumn&#x3D;numberelse4set signcolumn&#x3D;yesendif&quot; Use tab for trigger completion with characters ahead and navigate.&quot; NOTE: Use command &#39;:verbose imap &lt;tab&gt;&#39; to make sure tab is not mapped by&quot; other plugin before putting this into your config.inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;444\ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :444\ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :444\ coc#refresh()inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;function! s:check_back_space() abort4let col &#x3D; col(&#39;.&#39;) - 14return !col || getline(&#39;.&#39;)[col - 1]  &#x3D;~# &#39;\s&#39;endfunction&quot; Use &lt;c-space&gt; to trigger completion.if has(&#39;nvim&#39;)4inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()else4inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-@&gt; coc#refresh()endif&quot; Use &lt;cr&gt; to confirm completion, &#96;&lt;C-g&gt;u&#96; means break undo chain at current&quot; position. Coc only does snippet and additional edit on confirm.&quot; &lt;cr&gt; could be remapped by other vim plugin, try &#96;:verbose imap &lt;CR&gt;&#96;.if exists(&#39;*complete_info&#39;)4inoremap &lt;expr&gt; &lt;cr&gt; complete_info()[&quot;selected&quot;] !&#x3D; &quot;-1&quot; ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;else4inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;endif&quot; GoTo code navigation.nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;gy &lt;Plug&gt;(coc-type-definition)nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;gi &lt;Plug&gt;(coc-implementation)nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;gr &lt;Plug&gt;(coc-references)nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;gd &lt;Plug&gt;(coc-definition)let g:which_key_map1.g &#x3D; &#123;444\ &#39;name&#39;: &#39;+coc.goto&#39;,444\ &#39;y&#39; : &#39;go to type definition&#39;,444\ &#39;i&#39; : &#39;go to implementation&#39;,444\ &#39;r&#39; : &#39;go to references&#39;,444\ &#39;d&#39; : &#39;go to definition&#39;,444\ &#125;&quot; Use K to show documentation in preview window.nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;function! s:show_documentation()4if (index([&#39;vim&#39;,&#39;help&#39;], &amp;filetype) &gt;&#x3D; 0)44execute &#39;h &#39;.expand(&#39;&lt;cword&gt;&#39;)4else44call CocActionAsync(&#39;doHover&#39;)4endifendfunction&quot; Highlight the symbol and its references when holding the cursor.autocmd CursorHold * silent call CocActionAsync(&#39;highlight&#39;)&quot; Symbol renaming.nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;cr &lt;Plug&gt;(coc-rename)&quot; Formatting selected code.nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;cm &lt;Plug&gt;(coc-format-selected)xmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;cm &lt;Plug&gt;(coc-format-selected)let g:which_key_map1.c &#x3D; &#123;444\ &#39;name&#39; : &#39;+coc&#39;,444\ &#39;f&#39; : &#39;automatically fix errors in current line&#39;,444\ &#39;m&#39; : &#39;format selected code&#39;,444\ &#39;r&#39; : &#39;rename symbol&#39;,444\ &#125;augroup mygroup4autocmd!4&quot; Setup formatexpr specified filetype(s).4autocmd FileType typescript,json setl formatexpr&#x3D;CocAction(&#39;formatSelected&#39;)4&quot; Update signature help on jump placeholder.4autocmd User CocJumpPlaceholder call CocActionAsync(&#39;showSignatureHelp&#39;)augroup end&quot; Apply AutoFix to problem on the current line.nmap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;cf &lt;Plug&gt;(coc-fix-current)&quot; Add &#96;:Format&#96; command to format current buffer.command! -nargs&#x3D;0 Format :call CocAction(&#39;format&#39;)&quot; Add &#96;:Fold&#96; command to fold current buffer.command! -nargs&#x3D;? Fold :call     CocAction(&#39;fold&#39;, &lt;f-args&gt;)&quot; Add &#96;:OR&#96; command for organize imports of the current buffer.command! -nargs&#x3D;0 OR   :call     CocAction(&#39;runCommand&#39;, &#39;editor.action.organizeImport&#39;)&quot; Add (Neo)Vim&#39;s native statusline support.&quot; NOTE: Please see &#96;:h coc-status&#96; for integrations with external plugins that&quot; provide custom statusline: lightline.vim, vim-airline.set statusline^&#x3D;%&#123;coc#status()&#125;%&#123;get(b:,&#39;coc_current_function&#39;,&#39;&#39;)&#125;&quot; Mappings for CoCList&quot; open CocListnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;ct  :&lt;C-u&gt;CocList&lt;cr&gt;&quot; Show all diagnostics.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;ca  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;&quot; Manage extensions.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;ce  :&lt;C-u&gt;CocList extensions&lt;cr&gt;&quot; Show commands.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;cc  :&lt;C-u&gt;CocList commands&lt;cr&gt;&quot; Find symbol of current document.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;co  :&lt;C-u&gt;CocList outline&lt;cr&gt;&quot; Search workspace symbols.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;cs  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;&quot; Do default action for next item.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;cj  :&lt;C-u&gt;CocNext&lt;CR&gt;&quot; Do default action for previous item.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;cz  :&lt;C-u&gt;CocPrev&lt;CR&gt;&quot; Resume latest coc list.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;leader&gt;cp  :&lt;C-u&gt;CocListResume&lt;CR&gt;let g:which_key_map2.c &#x3D; &#123;444\ &#39;name&#39; : &#39;+coc&#39;,444\ &#39;t&#39; : &#39;open coc list&#39;,444\ &#39;a&#39; : &#39;show all diagnostics&#39;,444\ &#39;e&#39; : &#39;manage extensions&#39;,444\ &#39;c&#39; : &#39;show commands&#39;,444\ &#39;o&#39; : &#39;find symbol of current document&#39;,444\ &#39;s&#39; : &#39;search workspace symbols&#39;,444\ &#39;j&#39; : &#39;do default action for next item&#39;,444\ &#39;z&#39; : &#39;do default action for previous item&#39;,444\ &#39;p&#39; : &#39;resume latest coc list&#39;,444\ &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Browse and Save Files that Require Root Permissions In Neovim</title>
      <link href="2020/10/18/browse-and-save-files-that-require-root-permissions-in-neovim/"/>
      <url>2020/10/18/browse-and-save-files-that-require-root-permissions-in-neovim/</url>
      
        <content type="html"><![CDATA[<h1 id="Neovim浏览及保存需要root权限的文件"><a href="#Neovim浏览及保存需要root权限的文件" class="headerlink" title="Neovim浏览及保存需要root权限的文件"></a>Neovim浏览及保存需要root权限的文件</h1><h2 id="vim保存时获取root权限"><a href="#vim保存时获取root权限" class="headerlink" title="vim保存时获取root权限"></a>vim保存时获取root权限</h2><p>vim可以在保存文件时使用<code>:w !  sudo  tee  %</code>获取权限。但neovim暂不支持该命令，或者说无法输入密码。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>安装<a href="https://github.com/lambdalisue/suda.vim"><code>suda.vim</code>插件</a>。</p><p>接着在<code>init.vim</code>设置<code>let g:suda_smart_edit = 1</code>即可。插件会自动检测文件权限。当保存需要权限时，会自动提示输入密码。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo System Further Improvement</title>
      <link href="2020/08/08/gentoo-system-further-improvement/"/>
      <url>2020/08/08/gentoo-system-further-improvement/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo 教程目录</a></p><h1 id="Gentoo-系统完善"><a href="#Gentoo-系统完善" class="headerlink" title="Gentoo 系统完善"></a>Gentoo 系统完善</h1><p>本文介绍 gentoo 系统的进一步完善。主要包括一些软件的安装和一些系统配置。</p><h2 id="添加-gentoo-zh-overlay"><a href="#添加-gentoo-zh-overlay" class="headerlink" title="添加 gentoo-zh overlay"></a>添加 gentoo-zh overlay</h2><p>gentoo-zh 包含了许多国内常用的软件。</p><pre class="line-numbers language-none"><code class="language-none">emerge eselect-repositoryeselect repository add gentoo-zh git https:&#x2F;&#x2F;github.com&#x2F;microcai&#x2F;gentoo-zheix-sync# 或者可以直接使用layman<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果同步时发生错误<code>Main gentoo tree does not appear to have changed: exiting</code>，可以<code>rm -rf /var/db/repos/*</code>或者<code>eix-sync -a</code>解决。</p><h2 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h2><ul><li>安装 fontconfig</li></ul><p>添加 USE flag<code>static-libs</code></p><p><code>emerge media-libs/fontconfig</code></p><p>更多配置见<a href="https://wiki.gentoo.org/wiki/Fontconfig">gentoo wiki fontdconfig</a>。</p><ul><li>安装字体（不需要全部安装）</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge media-fonts&#x2F;font-isas-miscemerge media-fonts&#x2F;arphicfontsemerge media-fonts&#x2F;opendesktop-fontsemerge media-fonts&#x2F;wqy-zenheiemerge media-fonts&#x2F;zh-kcfonts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>激活字体</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看字体配置文件eselect fontconfig list# 激活上面安装的字体eselect fontconfig enable number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>（可选）将区域改为中文</li></ul><pre class="line-numbers language-none"><code class="language-none"># 列出可用的区域eselect locale list# 选择中文区域的编号eselect locale set 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置桌面使用中文语言</li></ul><p>值得注意的是 kde 桌面不能完全汉化。如果你不能接受，干脆用全英文。</p><pre class="line-numbers language-none"><code class="language-none">nvim ~&#x2F;.xprofileexport LANG&#x3D;zh_CN.UTF-8export LANGUAGE&#x3D;zh_CN:en_US<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>这里选用 fcitx5 作为输入法。</p><ul><li>安装输入法</li></ul><pre class="line-numbers language-none"><code class="language-none"># 编辑&#x2F;etc&#x2F;portage&#x2F;package.accept_keywords&#x2F;fcitx5，加入&#x3D;app-i18n&#x2F;fcitx5-999999999 **&#x3D;app-i18n&#x2F;kcm-fcitx5-99999999 **&#x3D;app-i18n&#x2F;fcitx5-qt-9999999999 **app-i18n&#x2F;fcitx5-chinese-addons&#x3D;app-i18n&#x2F;libime-99999999 **&#x3D;x11-libs&#x2F;xcb-imdkit-99999999999 **&#x3D;app-i18n&#x2F;cldr-emoji-annotation-9999 **&#x3D;app-i18n&#x2F;fcitx5-gtk-999999999 **<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">emerge boostemerge xcb-imdkit cldr-emoji-annotation fcitx5 kcm-fcitx5 fcitx5-qt fcitx5-chinese-addons libime fcitx5-gtk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>app-text/enchant-1.6.1-r1</code>编译失败的解决方案为设置 CC 和 CXX 为</p><pre class="line-numbers language-none"><code class="language-none">CC&#x3D;x86_64-pc-linux-gnu-gccCXX&#x3D;x86_64-pc-linux-gnu-g++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>libime 如果编译失败，可尝试修改<code>=app-i18n/libime-99999999 **</code>为<code>app-i18n/libime</code>（<code>fcitx5-chinese-addons</code>失败同理）。</p><pre class="line-numbers language-none"><code class="language-none"># 修改~&#x2F;.xprofileexport GTK_IM_MODULE&#x3D;fcitx5export QT_IM_MODULE&#x3D;fcitx5export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mkdir ~&#x2F;.config&#x2F;autostartcp &#x2F;usr&#x2F;share&#x2F;applications&#x2F;fcitx5.desktop ~&#x2F;.config&#x2F;autostart# 自启动也可以在系统设置 start and shutdown 中设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>安装主题</li></ul><p>先关闭 fcitx5</p><pre class="line-numbers language-none"><code class="language-none">mkdir -p ~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;themes&#x2F;Material-Color# 以hosxy&#x2F;Fcitx5-Material-Color为例git clone https:&#x2F;&#x2F;github.com&#x2F;hosxy&#x2F;Fcitx5-Material-Color.git ~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;themes&#x2F;Material-Colorcd ~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;themes&#x2F;Material-Colorln -sf .&#x2F;panel-teal.png panel.pngln -sf .&#x2F;highlight-teal.png highlight.png# 修改~&#x2F;.config&#x2F;fcitx5&#x2F;conf&#x2F;classicui.confVertical Candidate List&#x3D;FalsePerScreenDPI&#x3D;TrueTheme&#x3D;Material-Color<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多配置可以直接在<code>kcm-fcitx5</code>中配置。</p><h2 id="tlp"><a href="#tlp" class="headerlink" title="tlp"></a>tlp</h2><pre class="line-numbers language-none"><code class="language-none">eselect repository add tlp git https:&#x2F;&#x2F;github.com&#x2F;dywisor&#x2F;tlp-portage# 修改&#x2F;etc&#x2F;portage&#x2F;package.accept_keywords&#x2F;tlpapp-laptop&#x2F;tlpsys-power&#x2F;linux-x86-power-tools# 安装emerge tlpsystemctl enable tlp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><pre class="line-numbers language-none"><code class="language-none">emerge zsh# 设置zsh为默认shellchsh -s &#x2F;bin&#x2F;zsh# 查看当前shellecho $SHELL# 安装oh-my-zshgit clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zshcp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc# 配置oh-my-zshgit clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlightinggit clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestionsnvim ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;zsh-autosuggestions&#x2F;zsh-autosuggestions.zshZSH_AUTOSUGGEST_HIGHLIGHT_STYLE&#x3D;’fg&#x3D;20’nvim ~&#x2F;.zshrc# 设置主题ZSH_THEME&#x3D;&quot;ys&quot;# 设置插件plugins&#x3D;(git z zsh-syntax-highlighting zsh-autosuggestions extract vi-mode)source ~&#x2F;.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h2><pre class="line-numbers language-none"><code class="language-none">emerge xmodmapxmodmap -pke &gt; ~&#x2F;.Xmodmap# 修改 ~&#x2F;.Xmodmap，具体配置自行查询。xmodmap ~&#x2F;.Xmodmap # 用ssh连接是无法启动的，需要在主机上执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="触控板手势配置"><a href="#触控板手势配置" class="headerlink" title="触控板手势配置"></a>触控板手势配置</h3><pre class="line-numbers language-none"><code class="language-none">sudo gpasswd -a $USER inputemerge x11-misc&#x2F;libinput-gestureslibinput-gestures-setup autostart# 查看dev-libs&#x2F;libinput和x11-drivers&#x2F;xf86-input-libinput以及x11-misc&#x2F;xdotool是否缺失，缺则补mkdir &#x2F;etc&#x2F;X11&#x2F;xorg.conf.dcp &#x2F;usr&#x2F;share&#x2F;X11&#x2F;xorg.conf.d&#x2F;40-libinput.conf &#x2F;etc&#x2F;X11&#x2F;xorg.conf.d&#x2F;40-libinput.confcp &#x2F;etc&#x2F;libinput-gestures.conf ~&#x2F;.config&#x2F;libinput-gestures.conf# 修改 ~&#x2F;.config&#x2F;libinput-gestures.conf，具体配置自行查询。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="grub-主题"><a href="#grub-主题" class="headerlink" title="grub 主题"></a>grub 主题</h2><p><a href="https://www.gnome-look.org/browse/cat/109/">下载 grub 主题</a></p><p>将主题包解压后放在<code>/boot/grub/themes</code>下。</p><pre class="line-numbers language-none"><code class="language-none"># 修改&#x2F;etc&#x2F;default&#x2F;grubGRUB_THEME&#x3D;&quot;&#x2F;boot&#x2F;grub&#x2F;themes&#x2F;主题包名&#x2F;theme.txt&quot;GRUB_GFXMODE&#x3D;&quot;1920x1080x32&quot;# 更新配置grub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="启用-snap"><a href="#启用-snap" class="headerlink" title="启用 snap"></a>启用 snap</h2><ul><li>添加 USE flag</li></ul><pre class="line-numbers language-none"><code class="language-none">sys-apps&#x2F;systemd policykit apparmorsys-libs&#x2F;libseccomp static-libs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>开启测试分支</li></ul><pre class="line-numbers language-none"><code class="language-none">sys-libs&#x2F;libapparmorsys-apps&#x2F;apparmorapp-emulation&#x2F;snapdsec-policy&#x2F;apparmor-profiles<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>安装包</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge sys-apps&#x2F;systemdemerge sys-apps&#x2F;apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>修改 grub 配置</li></ul><pre class="line-numbers language-none"><code class="language-none">nvim &#x2F;etc&#x2F;default&#x2F;grub# 添加GRUB_CMDLINE_LINIX_DEFAULT&#x3D;&quot;apparmor&#x3D;1 security&#x3D;apparmor&quot;grub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>安装 snap</li></ul><pre class="line-numbers language-none"><code class="language-none">layman -a snapdeix-sync# 内核需要开启CONFIG_SECURITY_APPARMOR# 如果前面采用的是自动编译，则可以将此项加入&#x2F;usr&#x2F;src&#x2F;linux&#x2F;.config，再重新编译内核emerge --ask app-emulation&#x2F;snapdsudo systemctl enable --now snapdsudo systemctl enable --now snapd.socketsudo systemctl enable --now snapd.apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>snap 加速</li></ul><pre class="line-numbers language-none"><code class="language-none">sudo systemctl edit snapd[Service]Environment&#x3D;&quot;http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:port&quot;Environment&#x3D;&quot;https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:port&quot;sudo systemctl daemon-reloadsudo systemctl restart snapd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Kool Desktop Environment Installation</title>
      <link href="2020/08/08/gentoo-kool-desktop-environment-installation/"/>
      <url>2020/08/08/gentoo-kool-desktop-environment-installation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo 教程目录</a></p><h1 id="Gentoo-KDE-桌面安装"><a href="#Gentoo-KDE-桌面安装" class="headerlink" title="Gentoo KDE 桌面安装"></a>Gentoo KDE 桌面安装</h1><p>本文以 kde 为例，介绍 gentoo 系统桌面安装流程。</p><p>kde 桌面的安装可参考<a href="https://wiki.gentoo.org/wiki/KDE/">gentoo wiki</a>。</p><h2 id="基本桌面环境安装"><a href="#基本桌面环境安装" class="headerlink" title="基本桌面环境安装"></a>基本桌面环境安装</h2><p>参考上面的链接，安装<code>kde-plasma</code>以及应用程序包。</p><pre class="line-numbers language-none"><code class="language-none">systemctl enable sddm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装使用-NetworkManager"><a href="#安装使用-NetworkManager" class="headerlink" title="安装使用 NetworkManager"></a>安装使用 NetworkManager</h2><ul><li>安装</li></ul><p>参考<a href="https://wiki.gentoo.org/wiki/NetworkManager">gentoo wiki</a>。</p><ul><li>允许用户使用</li></ul><pre class="line-numbers language-none"><code class="language-none">gpasswd -a &lt;user_name&gt; plugdev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>开机启动</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl enable NetworkManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启，测试是否可以进入图形界面。</p><p>下一篇：<a href="https://www.niuiic.top/2020/08/08/gentoo-system-further-improvement/">Gentoo System Further Improvement</a></p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Basic System Installation</title>
      <link href="2020/08/07/gentoo-basic-system-installation/"/>
      <url>2020/08/07/gentoo-basic-system-installation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo 教程目录</a></p><h1 id="Gentoo-基本系统安装"><a href="#Gentoo-基本系统安装" class="headerlink" title="Gentoo 基本系统安装"></a>Gentoo 基本系统安装</h1><p>本文介绍 gentoo 基本系统的一般安装流程。图形界面的安装配置将在后面的文章中介绍。</p><h2 id="刻录-gentoo-安装镜像"><a href="#刻录-gentoo-安装镜像" class="headerlink" title="刻录 gentoo 安装镜像"></a>刻录 gentoo 安装镜像</h2><p>访问<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a>。选择合适的架构，下载 gentoo 安装镜像。</p><p><img src="1.png" alt="安装镜像列表"></p><p>虚拟机不需要刻录。u 盘的刻录步骤很简单，不再赘述。</p><h2 id="开启网络与-ssh"><a href="#开启网络与-ssh" class="headerlink" title="开启网络与 ssh"></a>开启网络与 ssh</h2><ul><li>有线网卡与虚拟机</li></ul><p>直接<code>dhcpcd</code>即可</p><ul><li>wifi</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看无限网卡名称及状态ip a# 若无限网卡未打开，则开启ip link set interface_name up# 查看可用的wifi# 建议直接从其他设备上查看wifi名称，不必从本地扫描搜索# 生成wifi配置wpa_passphrase 网络 密码 &gt; 文件# 连接wifiwpa_supplicant -c 文件 -i 接口 &amp;# 自动分配ip地址dhcpcd &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>开启 ssh</li></ul><pre class="line-numbers language-none"><code class="language-none"># 开启ssh&#x2F;etc&#x2F;init.d&#x2F;sshd start# 设置livecd密码passwd# 注意远程连接时用户名不是livecd，而是root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>详见</p><p><a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Disks/zh-cn">gentoo wiki</a><br><a href="https://wiki.gentoo.org/wiki/Handbook:X86/Blocks/Disks/zh-cn">gentoo handbook</a></p><p>由于此处分配分区将牵扯到后面 fstab 的配置，如果你对此完全不了解，建议按最常规的方式划分。如果你有一台现成的 linux，可以仿照其分区，可以帮助后面配置 fstab。</p><p>另外参考你的电脑配置。内存与交换空间之和（单位 G）最好大于 CPU 总线程数。</p><p>以下是 GPT 格式分区，引导方式为 EFI。</p><pre class="line-numbers language-none"><code class="language-none">fdisk -l# 注意以下磁盘名nvme0n1，对于不同规格的硬盘不同fdisk &#x2F;dev&#x2F;nvme0n1g# 分区，具体操作略w# 注意以下分区格式将关系到部分软件，尤其是grub的安装配置。因此必须慎重选择。# 制作引导分区mkfs.fat -F32 &#x2F;dev&#x2F;nvme0n1p1# 制作主分区mkfs.ext4 &#x2F;dev&#x2F;nvme0n1p2# 制作交换分区mkswap &#x2F;dev&#x2F;nvme0n1p3# 启用交换swapon &#x2F;dev&#x2F;nvme0n1p3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分区完毕后将主分区挂在到 livecd 提供的挂载点上。</p><pre class="line-numbers language-none"><code class="language-none">mount &#x2F;dev&#x2F;nvme0n1p2 &#x2F;mnt&#x2F;gentoo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="获取基础编译环境"><a href="#获取基础编译环境" class="headerlink" title="获取基础编译环境"></a>获取基础编译环境</h2><p>上述步骤已经为 gentoo 系统开辟了空间，下面将正式进入系统的编译安装阶段。</p><p>由于 gentoo livecd 并不携带完整的编译环境，因此我们需要先往系统空间中放一个现成的编译环境，即 gentoo 基础编译环境。</p><p>再次访问<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华镜像站</a>。</p><p>Gentoo 的 stage3 包囊括了整套编译环境以及绝大多数 gentoo 基础工具。</p><p><img src="2.png" alt="stage3"></p><p>Gentoo stage3 包的类型包括但不限于以上几种。根据你所需要的桌面环境，查看其对应的 gentoo wiki，做出选择。其中无 systemd 表示使用 OpenRC。nomultilib 表示仅支持 64 位，一般不建议选择。</p><p>本教程以 systemd kde 为例，因此选择下载以下几个包至<code>/mnt/gentoo</code>。</p><p><img src="3.png" alt="systemd stage3"></p><p>下载完毕后使用<code>sha512sum -c stage3-amd64-*.tar.xz.DIGESTS</code>校验文件，出现两个 ok 和两个 failed 为正常。并继续使用<code>tar xpvf stage3-*.tar.xz --xattrs-include=&#39;*.*&#39; --numeric-owner</code>解压文件。</p><h2 id="设置编译选项"><a href="#设置编译选项" class="headerlink" title="设置编译选项"></a>设置编译选项</h2><p>配置<code>/mnt/gentoo/etc/portage/make.conf</code>。</p><p>这是整个安装过程中最核心、最重要的一步。详情参考<a href="https://wiki.gentoo.org/wiki//etc/portage/make.conf">Gentoo wiki</a>以及<a href="https://dev.gentoo.org/~zmedico/portage/doc/man/make.conf.5.html">gentoo doc</a>。</p><p>此处不再对大部分配置进行说明，仅给出笔者第一次安装 gentoo 时的配置（虽不完美，但在当时不存在错误）。只可参考，不可照抄。</p><pre class="line-numbers language-none"><code class="language-none">COMMON_FLAGS&#x3D;&quot;-march&#x3D;native -O2 -pipe&quot;CFLAGS&#x3D;&quot;$&#123;COMMON_FLAGS&#125;&quot;CXXFLAGS&#x3D;&quot;$&#123;COMMON_FLAGS&#125;&quot;FCFLAGS&#x3D;&quot;$&#123;COMMON_FLAGS&#125;&quot;FFLAGS&#x3D;&quot;$&#123;COMMON_FLAGS&#125;&quot;CHOST&#x3D;&quot;x86_64-pc-linux-gnu&quot;CONFIG_PROTECT&#x3D;&quot;&#x2F;var&#x2F;bind&quot;PORTDIR&#x3D;&quot;&#x2F;var&#x2F;db&#x2F;repos&#x2F;gentoo&quot;DISTDIR&#x3D;&quot;&#x2F;var&#x2F;cache&#x2F;distfiles&quot;PKGDIR&#x3D;&quot;&#x2F;var&#x2F;cache&#x2F;binpkgs&quot;LC_MESSAGES&#x3D;CMAKEOPTS&#x3D;&quot;-j9&quot;GENTOO_MIRRORS&#x3D;&quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gentoo&quot;PORTAGE_TMPDIR&#x3D;&quot;&#x2F;var&#x2F;tmp&quot;DISTDIR&#x3D;&#x2F;var&#x2F;gentoo&#x2F;distfilesACCEPT_LICENSE&#x3D;&quot;*&quot;VIDEO_CARDS&#x3D;&quot;radeon&quot;L10N&#x3D;&quot;en_US en zh zh_CN&quot;LINGUAS&#x3D;&quot;en-US zh-CN en zh&quot;AUTO_CLEAN&#x3D;&quot;yes&quot;GRUB_PLATFORMS&#x3D;&quot;efi-64&quot;EMERGE_DEFAULT_OPTS&#x3D;&quot;--with-bdeps&#x3D;y --ask --verbose&#x3D;y --load-average --keep-going&quot;INPUT_DEVICES&#x3D;&quot;libinput synaptics evdev&quot;USE&#x3D;&quot;X alsa clang udev dbus polkit udisks vulkan vdpau vaapi glamor nls&quot;KEYWORDS&#x3D;&quot;amd64&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面对其中的几个选项做简略介绍。</p><p><code>GENTOO_MIRRORS</code>：建议选清华源。虽然清华源的速度中规中矩，时不时还出点问题。但 gentoo 在中国境内的源很少，应该也只有清华源在及时更新。</p><p><code>EMERGE_DEFAULT_OPTS</code>：建议添加，可大大减小 emerge 指令长度。</p><p><code>INPUT_DEVICES</code>：绝不可缺。否则会引起键盘、觸控板、鼠标失效等等问题。</p><p><code>KEYWORDS</code>：不要在这里开启测试分支。</p><p><code>MAKEOPTS</code>：建议等于 CPU 线程数+1。这样计算机在编译软件时尚有余力编译另外的软件或者进行其他操作。</p><h2 id="进一步配置"><a href="#进一步配置" class="headerlink" title="进一步配置"></a>进一步配置</h2><pre class="line-numbers language-none"><code class="language-none">mkdir --parents &#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;repos.confcp &#x2F;mnt&#x2F;gentoo&#x2F;usr&#x2F;share&#x2F;portage&#x2F;config&#x2F;repos.conf &#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;portage&#x2F;repos.conf&#x2F;gentoo.confcp --dereference &#x2F;etc&#x2F;resolv.conf &#x2F;mnt&#x2F;gentoo&#x2F;etc&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改<code>/mnt/gentoo/etc/portage/repos.conf/gentoo.conf</code>配置 portage 镜像源</p><pre class="line-numbers language-none"><code class="language-none">sync-uri &#x3D; rsync:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gentoo-portage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="进入新系统"><a href="#进入新系统" class="headerlink" title="进入新系统"></a>进入新系统</h2><ul><li>挂载剩余文件系统</li></ul><pre class="line-numbers language-none"><code class="language-none">mount --types proc &#x2F;proc &#x2F;mnt&#x2F;gentoo&#x2F;procmount --rbind &#x2F;sys &#x2F;mnt&#x2F;gentoo&#x2F;sysmount --make-rslave &#x2F;mnt&#x2F;gentoo&#x2F;sysmount --rbind &#x2F;dev &#x2F;mnt&#x2F;gentoo&#x2F;devmount --make-rslave &#x2F;mnt&#x2F;gentoo&#x2F;dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>chroot 登陆新系统</li></ul><pre class="line-numbers language-none"><code class="language-none">chroot &#x2F;mnt&#x2F;gentoo &#x2F;bin&#x2F;bashsource &#x2F;etc&#x2F;profileexport PS1&#x3D;&quot;(chroot) $&#123;PS1&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>挂载 boot 分区</li></ul><pre class="line-numbers language-none"><code class="language-none">mount &#x2F;dev&#x2F;nvme0n1p1 &#x2F;boot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置-Portage"><a href="#配置-Portage" class="headerlink" title="配置 Portage"></a>配置 Portage</h2><ul><li>下载数据库快照</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge-webrsync<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选择 profile</li></ul><p>profile 简单的说就是一系列 USE flag 等配置的集合。这将是新系统的主体配置。</p><pre class="line-numbers language-none"><code class="language-none"># 先列出可用的profile，带星号是目前选择的eselect profile list# 选择你需要的profile（可以从gentoo wiki获得信息）。这里选择kde桌面对应的profileeselect profile set default&#x2F;linux&#x2F;amd64&#x2F;17.1&#x2F;desktop&#x2F;plasma&#x2F;systemd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>17.0 与 17.1 版本差距并不是非常大，如果不想深究，可以随意选择。</p><h2 id="系统工具优化"><a href="#系统工具优化" class="headerlink" title="系统工具优化"></a>系统工具优化</h2><p>所谓工欲善其事，必先利其器。因此在正式编译系统之前，先进行部分工具的完善。</p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>如果你不喜欢 stage3 中解压出来的 nano，可以优先安装一款自己喜欢的编辑器。</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>使用 git 同步 portage。</p><p>优点：大大提高同步速度。</p><p>缺点：略占用更多空间。</p><p>安装 git，不赘述。</p><p>修改当前系统的<code>/etc/portage/repos.conf/gentoo.conf</code></p><pre class="line-numbers language-none"><code class="language-none">[gentoo]sync-type &#x3D; gitsync-uri &#x3D; https:&#x2F;&#x2F;github.com&#x2F;gentoo-mirror&#x2F;gentoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 移除之前同步的portagerm -rf &#x2F;mnt&#x2F;gentoo&#x2F;var&#x2F;db&#x2F;repos&#x2F;gentoo&#96;# 同步portage&#96;emerge --sync&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gentoolkit"><a href="#gentoolkit" class="headerlink" title="gentoolkit"></a>gentoolkit</h3><p>安装 gentoolkit，不赘述。</p><ul><li>常用指令</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看已经enable的USE flageuse -a -g或者euse -a -l# 激活USE flageuse -E flagname# 关闭USE flageuse -D flagname# 注意不可单独使用euse -D或者euse -E。这将作用到所有的USE flag。# 查看指定包的use标志equery --nocolor uses &#x3D;gnumeric-1.12.31# 清理源代码eclean-dist# 清理二进制包eclean-pkg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>eclean 说明</li></ul><p>默认情况下当前存储库中的任何 ebuild 相对应的源文件和二进制包都不会被删除。</p><p>可以通过同时使用 <code>--deep</code> 和 <code>--package-names</code> 选项指定删除当前存储库中 ebuild 对应的源文件和二进制包。</p><h3 id="安装-layman"><a href="#安装-layman" class="headerlink" title="安装 layman"></a>安装 layman</h3><p>layman 是一个优秀的 gentoo overlay 管理工具。eix-sync 指令中也集成了<code>layman -S</code>指令。</p><p>详情见<a href="https://wiki.gentoo.org/wiki/Layman">gentoo wiki</a>。</p><ul><li>layman 安装</li></ul><p>建议开启的 USE flag 有 git、sync-plugin-portage。</p><pre class="line-numbers language-none"><code class="language-none">emerge --ask app-portage&#x2F;laymanmkdir &#x2F;etc&#x2F;portage&#x2F;repos.conflayman-updater -R<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>相关指令</li></ul><pre class="line-numbers language-none"><code class="language-none">layman -L # 显示存储库列表layman -a &lt;name&gt; # 从本地列表添加存储库layman -o &lt;url of repository xml file&gt; -f -a &lt;name&gt; # 添加非官方存储库layman -d &lt;name&gt; # 删除存储库layman -s &lt;name&gt; # 更新存储库layman -S # 更新所有存储库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装-eix"><a href="#安装-eix" class="headerlink" title="安装 eix"></a>安装 eix</h3><p>详情见<a href="https://wiki.gentoo.org/wiki/Eix">gentoo wiki</a>。</p><p>eix 在教程的前面的内容中已经提及并作简要介绍。</p><ul><li>eix 安装</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge app-portage&#x2F;eixeix-updateeix-sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>eix-sync</code>代替<code>emerge --sync</code>，可以在同步数据库后自动更新 eix 的缓存。</p><p>修改<code>/etc/eix-sync.conf</code>，写入<code>*</code>，以同步 ebuild 存储库。</p><ul><li>相关指令</li></ul><pre class="line-numbers language-none"><code class="language-none"># 搜索包eix name# 搜索本地包eix -I name# 在软件包描述文件中搜索，-c用于输出紧凑的结果eix -S -c name# 在包类别中搜索eix -C name# 搜索许可证eix -Cc games-rpg -L &quot;EULA&quot;# 排除结果eix --not -L &quot;EULA&quot;# 搜索过时的包eix-test-obsolete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装-ccache"><a href="#安装-ccache" class="headerlink" title="安装 ccache"></a>安装 ccache</h3><p>ccache 原理是缓存编译时的中间结果，当重新编译时就可以大大减少编译时间。其应用场景主要为编译失败后修改配置，然后再次编译。此时之前编译的有效内容可以直接被利用，这部分将以极快的速度完成编译。但是第一次运行 ccache 时，会拖慢编译速度。</p><ul><li>ccache 安装</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge --ask ccachemkdir -p &#x2F;var&#x2F;cache&#x2F;ccachechown root:portage &#x2F;var&#x2F;cache&#x2F;ccache&#x2F;chmod 2775 &#x2F;var&#x2F;cache&#x2F;ccache&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改<code>/etc/portage/make.conf</code>。</p><pre class="line-numbers language-none"><code class="language-none">FEATURES&#x3D;&quot;ccache&quot;CCACHE_DIR&#x3D;&quot;&#x2F;var&#x2F;cache&#x2F;ccache&quot;CCACHE_SIZE&#x3D;&quot;16G&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="开启-32-位库支持"><a href="#开启-32-位库支持" class="headerlink" title="开启 32 位库支持"></a>开启 32 位库支持</h3><p>Gentoo 官方并不建议使用纯 64 位模式。其最现实的原因是几乎无法改回兼容 32 位的模式。因此对于新手而言，强烈建议选择兼容 32 位的模式。</p><p>然而之前下载 stage3 包虽不是 nomultilib，但并不完全适配 32 位编译环境，需要手动修复。</p><pre class="line-numbers language-none"><code class="language-none">emerge --ask --verbose db# 编辑&#x2F;etc&#x2F;portage&#x2F;package.use&#x2F;abi_x86_32，写入sys-libs&#x2F;zlib abi_x86_32# 编辑&#x2F;etc&#x2F;portage&#x2F;make.conf，写入ABI_X86&#x3D;&quot;32 64&quot;emerge --ask --verbose zlib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局域网编译与打包分发"><a href="#局域网编译与打包分发" class="headerlink" title="局域网编译与打包分发"></a>局域网编译与打包分发</h3><p>Gentoo 可以联合局域网下的多台主机一起编译，也可以将本地编译好的包打包分发。</p><p>考虑到一般个人用户不太会用到这些功能，此处不赘述。详情见<a href="https://wiki.gentoo.org/wiki/Handbook:Parts/Full/Working/zh-cn#.E5.B0.86.E9.A2.84.E6.9E.84.E5.BB.BA.E7.9A.84.E8.BD.AF.E4.BB.B6.E5.8C.85.E5.88.86.E5.8F.91.E7.BB.99.E4.BB.96.E4.BA.BA">gentoo handbook</a>，<a href="https://docs.huihoo.com/gentoo/resources/document-listing/distcc.html">gentoo doc</a>以及<a href="https://wiki.gentoo.org/wiki/Distcc/zh-cn">gentoo wiki</a>。</p><h2 id="配置时间和区域"><a href="#配置时间和区域" class="headerlink" title="配置时间和区域"></a>配置时间和区域</h2><p>时间与区域可以在之后配置，此处提前配置主要是为了方便某些 GFW 偷渡者。PS：这种东西很重要，甚至直接关系到能否成功安装，但得你自己想办法。</p><ul><li>时区</li></ul><pre class="line-numbers language-none"><code class="language-none">echo Asia&#x2F;Shanghai &gt; &#x2F;etc&#x2F;timezone emerge --config sys-libs&#x2F;timezone-data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>区域</li></ul><pre class="line-numbers language-none"><code class="language-none"># 生成中英文 locale.genecho &#39;zh_CN.UTF-8 UTF-8&#39; &gt;&gt; &#x2F;etc&#x2F;locale.genecho &#39;en_US.UTF-8 UTF-8&#39; &gt;&gt; &#x2F;etc&#x2F;locale.genlocale-gen# 列出可用的区域eselect locale list# 选择英文区域的编号eselect locale set 3# 重新加载环境变量env-update &amp;&amp; source &#x2F;etc&#x2F;profile &amp;&amp; export PS1&#x3D;&quot;(chroot) \$&#123;PS1&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意上述操作可能导致系统时间发生错误，可以手动纠正。但这可能导致/usr/bin/git 时间错误，致于无法安装 systemd。重装 git 可解决上述问题。</p><ul><li>时间修正</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看时间是否正确hwclockdatedate -s 2020&#x2F;03&#x2F;09date -s 11:50:30hwclock -w# 自动更新，但此时暂不可用timedatectl set-ntp true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重新编译-gcc"><a href="#重新编译-gcc" class="headerlink" title="重新编译 gcc"></a>重新编译 gcc</h2><p>为获取最适配本机的编译器，必须先配置并重新编译 gcc。即使你选择 clang 作为主编译器，也应当重新编译 gcc 的稳定分支。</p><p>警告：此处配置编译需要万分小心。一旦出现不当，损坏编译器，就会很麻烦。如果真的遇到这种情况，也无需慌张。通过直接安装已编译完成的正常的 gcc 二进制包救场即可。</p><ul><li>USE flag</li></ul><p>根据需求配置，以下仅为参考。</p><pre class="line-numbers language-none"><code class="language-none">fortran nls nptl openmp pch sanitize ssp lto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编译 gcc</li></ul><pre class="line-numbers language-none"><code class="language-none"># 更新Portageeix-sync# 编译安装gccemerge --ask gcc# 如果编译了新版本的gcc，继续进行下列操作。# 查看可用gcc版本gcc-config --list-profiles# 选择新编译出来的gccgcc-config 2source &#x2F;etc&#x2F;profileexport PS1&#x3D;&quot;(chroot) $&#123;PS1&#125;&quot;emerge --ask --oneshot --usepkg&#x3D;n sys-devel&#x2F;libtool# 检查当前gcc版本gcc -v# 如果需要拆卸旧版本emerge --ask --depclean &#x3D;sys-devel&#x2F;gcc-9.3.0# 验证系统完整性revdep-rebuild# 重新编译部分包emerge --ask --oneshot --usepkg&#x3D;n --verbose sys-devel&#x2F;llvm sys-devel&#x2F;clang# 如果有问题可以重新构建系统emerge --ask --emptytree --usepkg&#x3D;n @system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装-clang"><a href="#安装-clang" class="headerlink" title="安装 clang"></a>安装 clang</h2><p>笔者使用 clang 作为主编译器。即使你使用 gcc 作为主编译器，也可以选择安装 clang 解决部分编译错误问题（这在<a href="https://www.niuiic.top/2020/08/06/gentoo-compile-error-handling/">Gentoo Compile Error Handling</a>一文中已作介绍）。</p><p>重新编译整个系统。如果你不使用 clang 作为主编译器或者觉得没有必要，可以跳过此步。</p><pre class="line-numbers language-none"><code class="language-none">emerge --ask --emptytree --usepkg&#x3D;n @system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h2><pre class="line-numbers language-none"><code class="language-none"># 将数据库更新到最近一小时eix-syncemerge --oneshot sys-apps&#x2F;portage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>至此，所有准备工作都已进行完毕。</p><h2 id="更新-world"><a href="#更新-world" class="headerlink" title="更新@world"></a>更新@world</h2><p>编译安装所有在配置中需要的软件。但在此之前，需要先安装内核源代码提供内核版本信息。</p><pre class="line-numbers language-none"><code class="language-none">emerge sys-kernel&#x2F;gentoo-sourcesemerge --deep --with-bdeps&#x3D;y --changed-use --update --ask --verbose --keep-going @world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置-fstab"><a href="#配置-fstab" class="headerlink" title="配置 fstab"></a>配置 fstab</h2><p>fstab 简单的说就是系统启动时挂载文件系统的配置文件。</p><p>由 fstab 引起的常见错误有文件系统挂载为只读模式，无法写入任何文件等。</p><p>这里不介绍 fstab 的具体配置方法。有需要的参考<a href="https://wiki.gentoo.org/wiki/Fstab">gentoo wiki</a>。</p><p>前面提到，如果有现成的 linux 系统，完全可以仿照其分区方式。主要就是为了 copy 现成的<code>/etc/fstab</code>。</p><p>比如获得的文件如下</p><pre class="line-numbers language-none"><code class="language-none">UUID&#x3D;e5bc0d97-ac5c-400c-b26e-137cefe6ae68       &#x2F;               ext4            rw,relatime     0 1UUID&#x3D;B320-B5C7          &#x2F;boot           vfat            rw,relatime,fmask&#x3D;0022,dmask&#x3D;0022,codepage&#x3D;437,iocharset&#x3D;iso8859-1,shortname&#x3D;mixed,utf8,errors&#x3D;remount-ro       0 2UUID&#x3D;c4b396e5-cb87-42dc-b44e-4b26661e5cc0       none            swap            defaults        0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>blkid</code>获取文件系统的 UUID，替换文件中的 UUID 即可。</p><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><p>Gentoo 内核复杂点主要在于各选项的配置。此处不会介绍相关具体内容，只是提供一种投机取巧的方法。</p><p>具体的内核选项配置，参考<a href="https://wiki.gentoo.org/wiki/Kernel/Gentoo_Kernel_Configuration_Guide">gentoo wiki</a>。</p><h3 id="自动编译内核"><a href="#自动编译内核" class="headerlink" title="自动编译内核"></a>自动编译内核</h3><p>自动编译内核会开启大部分选项。不过如果不是对性能与简洁有极致的要求，着实是可以接受的。</p><ul><li>安装内核编译工具</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge sys-kernel&#x2F;genkernel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选择内核版本</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看源代码列表eselect kernel list# 选择eselect kernel set number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>自动编译内核</li></ul><pre class="line-numbers language-none"><code class="language-none">genkernel all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="手动编译内核"><a href="#手动编译内核" class="headerlink" title="手动编译内核"></a>手动编译内核</h3><ul><li>安装内核配置工具</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge --ask sys-apps&#x2F;pciutils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看功能</li></ul><p>通过<code>lsmod</code>命令来查看当前所处的 Gentoo Live 镜像开启的功能，这可以作为我们在配置内核时的重要参考。</p><ul><li>配置</li></ul><pre class="line-numbers language-none"><code class="language-none"># 进入源码菜单cd &#x2F;usr&#x2F;src&#x2F;linux# 打开配置工具make menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>按需求配置即可。</p><p>把上面所有必选项都配置好之后，选择 save 保存配置文件，然后 exit 退出。默认配置文件名是.config，但是最好手动复制一个备份，有时候默认名称的配置文件会莫名丢失，只能重头再配置一次。然后就可以开始编译和安装。</p><ul><li>编译安装内核</li></ul><pre class="line-numbers language-none"><code class="language-none">makemake modules_installmake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>投机取巧的方法</li></ul><p>先自动编译内核，等到输出信息显示配置完毕后打断进程，进入源码菜单，修改配置文件即可。这至少将提供一份正确的配置方案，在此基础上修改将节省大量时间。</p><h2 id="安装-firmware-和-initrampfs"><a href="#安装-firmware-和-initrampfs" class="headerlink" title="安装 firmware 和 initrampfs"></a>安装 firmware 和 initrampfs</h2><pre class="line-numbers language-none"><code class="language-none">emerge --ask sys-kernel&#x2F;linux-firmware# 如果是自动安装内核，则不需要下一步genkernel --install initramfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><p>此处的系统配置基于 Systemd，如果你使用的是 OpenRC，部分配置将不适用。</p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ul><li>修改<code>/etc/hostname</code></li></ul><p>设置主机名</p><pre class="line-numbers language-none"><code class="language-none">yourname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改<code>/etc/hosts</code></li></ul><pre class="line-numbers language-none"><code class="language-none"># 定义的是现在系统，假设主机名为tux127.0.0.1     localhost::1   localhost127.0.1.1   name.localdomain name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>网络工具的安装</li></ul><p>如果你想在安装完毕基础系统后不再使用 livecd，就需要先安装基础网络工具。之后等桌面环境安装完毕后，最终将采用 NetworkManager 作为 wifi 配置连接工具。</p><pre class="line-numbers language-none"><code class="language-none">emerge net-wireless&#x2F;wpa_supplicant dhcpcd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><pre class="line-numbers language-none"><code class="language-none">passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要 8 字符及以上。</p><p>也可以修改<code>/etc/pam.d/system-auth</code>，将<code>min=8,8,8,8,8 retry=3</code>中所有的 8 改为 1。</p><h3 id="部分系统工具的安装"><a href="#部分系统工具的安装" class="headerlink" title="部分系统工具的安装"></a>部分系统工具的安装</h3><ul><li>日志工具</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge --ask app-admin&#x2F;syslog-ngsystemctl enable syslog-ng@default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>远程登录</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl enable sshd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>文件系统工具</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge --ask sys-fs&#x2F;dosfstools sys-fs&#x2F;e2fsprogs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre class="line-numbers language-none"><code class="language-none">useradd -m -G users,wheel,audio -s &#x2F;bin&#x2F;bash usernamepasswd username # 需要三个单词，总长度大于8个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="磁盘清理"><a href="#磁盘清理" class="headerlink" title="磁盘清理"></a>磁盘清理</h3><pre class="line-numbers language-none"><code class="language-none">rm &#x2F;stage3-*.tar.*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装系统引导器"><a href="#安装系统引导器" class="headerlink" title="安装系统引导器"></a>安装系统引导器</h2><ul><li>安装 grub</li></ul><pre class="line-numbers language-none"><code class="language-none">emerge --ask --verbose sys-boot&#x2F;grub:2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将 grub 安装到系统中</li></ul><p>注意如果你不是 efi 引导，需要修改下列命令。</p><pre class="line-numbers language-none"><code class="language-none">grub-install --target&#x3D;x86_64-efi --efi-directory&#x3D;&#x2F;bootgrub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="安装配置-sudo"><a href="#安装配置-sudo" class="headerlink" title="安装配置 sudo"></a>安装配置 sudo</h3><pre class="line-numbers language-none"><code class="language-none">emerge --ask sudonvim &#x2F;etc&#x2F;sudoers# 在root ALL&#x3D;(ALL) ALL下添加新的用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置-sshd"><a href="#配置-sshd" class="headerlink" title="配置 sshd"></a>配置 sshd</h3><p>修改<code>/etc/ssh/sshd_config</code>，做以下修改。</p><pre class="line-numbers language-none"><code class="language-none">Port 22PermitRootLogin yesPasswordAuthentication yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="开启-SysRq"><a href="#开启-SysRq" class="headerlink" title="开启 SysRq"></a>开启 SysRq</h3><p>修改<code>/etc/sysctl.conf</code>。</p><pre class="line-numbers language-none"><code class="language-none">kernel.sysrq &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，Gentoo 基础系统已经安装完毕。退出 chroot，重启检查是否有误。</p><p>下一篇：<a href="https://www.niuiic.top/2020/08/08/gentoo-kool-desktop-environment-installation/">Gentoo Kool Desktop Environment Installation</a></p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Tutorials Directory</title>
      <link href="2020/08/06/gentoo-tutorials-directory/"/>
      <url>2020/08/06/gentoo-tutorials-directory/</url>
      
        <content type="html"><![CDATA[<h1 id="Gentoo-系列教程目录"><a href="#Gentoo-系列教程目录" class="headerlink" title="Gentoo 系列教程目录"></a>Gentoo 系列教程目录</h1><h2 id="Gentoo-Preface"><a href="#Gentoo-Preface" class="headerlink" title="Gentoo Preface"></a><a href="https://niuiic.top/2020/08/04/gentoo-preface/">Gentoo Preface</a></h2><h2 id="Gentoo-Package-Management"><a href="#Gentoo-Package-Management" class="headerlink" title="Gentoo Package Management"></a><a href="https://niuiic.top/2020/08/05/gentoo-package-management/">Gentoo Package Management</a></h2><h2 id="Gentoo-Compiler-Selection"><a href="#Gentoo-Compiler-Selection" class="headerlink" title="Gentoo Compiler Selection"></a><a href="https://niuiic.top/2020/08/05/gentoo-compiler-selection/">Gentoo Compiler Selection</a></h2><h2 id="Gentoo-Compile-Error-Handling"><a href="#Gentoo-Compile-Error-Handling" class="headerlink" title="Gentoo Compile Error Handling"></a><a href="https://niuiic.top/2020/08/06/gentoo-compile-error-handling/">Gentoo Compile Error Handling</a></h2><h2 id="Gentoo-Basic-System-Installation"><a href="#Gentoo-Basic-System-Installation" class="headerlink" title="Gentoo Basic System Installation"></a><a href="https://www.niuiic.top/2020/08/07/gentoo-basic-system-installation/">Gentoo Basic System Installation</a></h2><h2 id="Gentoo-Kool-Desktop-Environment-Installation"><a href="#Gentoo-Kool-Desktop-Environment-Installation" class="headerlink" title="Gentoo Kool Desktop Environment Installation"></a><a href="https://www.niuiic.top/2020/08/08/gentoo-kool-desktop-environment-installation/">Gentoo Kool Desktop Environment Installation</a></h2><h2 id="Gentoo-System-Further-Improvement"><a href="#Gentoo-System-Further-Improvement" class="headerlink" title="Gentoo System Further Improvement"></a><a href="https://www.niuiic.top/2020/08/08/gentoo-system-further-improvement/">Gentoo System Further Improvement</a></h2>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Preface</title>
      <link href="2020/08/06/vim-preface/"/>
      <url>2020/08/06/vim-preface/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim-前言"><a href="#Vim-前言" class="headerlink" title="Vim 前言"></a>Vim 前言</h1><h4 id="vim-是必要的？"><a href="#vim-是必要的？" class="headerlink" title="vim 是必要的？"></a>vim 是必要的？</h4><p>显然，“必要”是不存在的。无数现代编辑器以及各类 IDE 都可以成为替代对象。即使是在命令行中，也有 nano 等替代品。</p><h4 id="学习-vim-有什么好处？"><a href="#学习-vim-有什么好处？" class="headerlink" title="学习 vim 有什么好处？"></a>学习 vim 有什么好处？</h4><p>首先，尽管有那么多替代品，但vim至今仍保持着强大的生命力，送走了一代又一代所谓的“替代者”。vim的强大毋庸置疑。学习 vim 至少能让你多一件高效率工具。</p><p>其次，学习vim可以分为两类。一种是仅学习vim模式，另一种在此基础上深究vim编辑器的配套设施，即无与伦比的可扩展性。作为前者，可以大幅度提高码字、查找效率。作为后者，在此基础上能够享受亲手搭建最契合自己的编辑工具的快乐，能够深入了解插件体系的奥妙，能够提升自己的搜索技巧、专业知识、动手能力，甚至品性修养。学习vim只是一个表象，你想得到什么，肯花时间细细琢磨，就有可能从中获取什么。</p><h4 id="学习vim意味着放弃其他优秀编辑器？"><a href="#学习vim意味着放弃其他优秀编辑器？" class="headerlink" title="学习vim意味着放弃其他优秀编辑器？"></a>学习vim意味着放弃其他优秀编辑器？</h4><p>显然，这是个误区。退一万步讲，vim不仅是一个编辑器，更是一种编辑模式，一种可以并已经大量移植到其他编辑器上的模式。vim不可能永远适应所有的环境，当vim不能胜任时，不必固守，选择最适应的工具是最容易解决问题的办法。当然如果你愿意为自己的vim扩展相应的功能而去深入研究，自然是极好的。</p><h4 id="给vim初学者的忠告"><a href="#给vim初学者的忠告" class="headerlink" title="给vim初学者的忠告"></a>给vim初学者的忠告</h4><p>如果你想对vim进行大幅度扩展，linux系统将是你最好的选择，这里是程序员的天堂。同时，毫不夸张地讲，windows将是你的噩梦。</p><p>对学习的建议只有一步一步，坚持动手，不断尝试。从熟悉<code>hjkl</code>，到逐渐掌握各种跳转命令，查找、替换指令，学会安装第一个插件，使用插件管理器，为各种插件配置环境、指令，到深入研究vim高级功能，自己写插件等等。</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Compile Error Handling</title>
      <link href="2020/08/06/gentoo-compile-error-handling/"/>
      <url>2020/08/06/gentoo-compile-error-handling/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo教程目录</a></p><h1 id="Gentoo-编译错误解决方案"><a href="#Gentoo-编译错误解决方案" class="headerlink" title="Gentoo 编译错误解决方案"></a>Gentoo 编译错误解决方案</h1><p>本文介绍软件编译错误的常用解决方案。仅限于 gentoo 系统提供的操作，不涉及源代码层面的 bug 修复等内容。</p><h2 id="找出错误"><a href="#找出错误" class="headerlink" title="找出错误"></a>找出错误</h2><p>无论发生什么错误，知道是什么错误都是第一步。</p><p>gentoo 的 emerge 指令会在编译过程中输出 log，且在编译失败后打印错误信息以及日志文件地址等内容。及时查看并找到错误点是解决问题的第一步，也是最重要的一步。</p><h2 id="分析错误"><a href="#分析错误" class="headerlink" title="分析错误"></a>分析错误</h2><p>这里指的编译错误分为三类：编译前错误、编译期错误、安装期错误。</p><p>编译前错误五花八门，但解决难度一般较低，除非是严重的依赖问题。这类问题中大部分已经在<a href="https://www.niuiic.top/2020/08/05/gentoo-package-management/">Gentoo Package Management</a>一文中提及。这里不赘述。</p><p>编译期错误一般不会显示在最后的报错信息中，需要自行到 log 中查找。这类错误一般看起来像是源代码本身的 bug，但实际上绝大多数不过是编译选项、软件选项、编译器选择的问题。这类问题将在下文中作详细讨论。</p><p>安装期错误是最让人摸不着头脑的。这类错误也并无统一的解决方案。通常遇到这种错误时，第一时间使用 google 或其他搜索引擎搜索该错误信息。如果没有满意的结果，建议直接向打包者或源代码作者寻求帮助。当然如果你对 linux 系统的了解比较深，可能可以自行解决部分问题。</p><h2 id="解决错误的一般方案"><a href="#解决错误的一般方案" class="headerlink" title="解决错误的一般方案"></a>解决错误的一般方案</h2><p>如前所述，这里的解决方案针对编译期错误。建议参考下列方案的列写顺序以及错误信息的分析结果有顺序地进行尝试。</p><ul><li>重试</li></ul><p>重试看起来无效，但事实上是可能解决问题的。若重试一次无效，则无需再试。</p><ul><li>利用搜索引擎</li></ul><p>使用搜索引擎直接搜索错误信息是效率最高的搜索方法。但需要注意以下几点。</p><p>优先使用英文搜索，再考虑中文。</p><p>优先使用 google 搜索，再考虑其他。</p><p>如果错误信息看起来与 gentoo 无关联，则在适当位置加入 gentoo 关键字。</p><ul><li>更换编译器</li></ul><p>gcc 和 clang 互换，或者不同版本的同一编译器互换。这在用 clang 或者测试分支的 gcc 作为主编译器的情况下非常有效。</p><ul><li>减小编译线程数</li></ul><p>部分软件编译过程产生的临时文件过大，内存和交换无法负载，就会导致编译失败。</p><ul><li>设置编译选项</li></ul><p>主要是关闭编译优化。</p><p>但是还有一些特殊情况，该软件对 CC 及 CXX 的设置要求比较苛刻。比如<code>app-text/enchant-1.6.1-r1</code>，其要求的设置如下。</p><pre class="line-numbers language-none"><code class="language-none">CC&#x3D;x86_64-pc-linux-gnu-gccCXX&#x3D;x86_64-pc-linux-gnu-g++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>设置软件选项</li></ul><p>主要是 USE flag。一般通过错误信息判断可能是哪个 USE flag 管理的功能编译出错，将其禁用即可。</p><ul><li>控制软件版本</li></ul><p>升级或降级。</p><ul><li>打补丁</li></ul><p>前面使用搜索引擎搜索时注意某些软件可能已经给出修复 bug 的补丁。但这些补丁并未直接加入 ebuild。这时需要手动添加。</p><p>以<code>x11-misc/pcmanfm-1.2.5</code>为例。<code>mkdir -p /etc/portage/patches/x11-misc/pcmanfm-1.2.5</code>。然后将补丁放在该目录下，重新编译即可。</p><ul><li>等待上游修复 bug</li></ul><p>看起来是个逃避问题的选择，但实际上是相当常用且实用的方案。</p><h2 id="解决错误的高级方案"><a href="#解决错误的高级方案" class="headerlink" title="解决错误的高级方案"></a>解决错误的高级方案</h2><p>以上方案已经足以应对绝大多数编译错误。剩下的部分问题，除了源代码的 bug，其他的基本都可以使用重写 ebuild 解决。这将在后面的文章中介绍。</p><p>下一篇：<a href="https://www.niuiic.top/2020/08/07/gentoo-basic-system-installation/">Gentoo Basic System Installation</a></p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Compiler Selection</title>
      <link href="2020/08/05/gentoo-compiler-selection/"/>
      <url>2020/08/05/gentoo-compiler-selection/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo教程目录</a></p><h1 id="Gentoo-编译器选择"><a href="#Gentoo-编译器选择" class="headerlink" title="Gentoo 编译器选择"></a>Gentoo 编译器选择</h1><p>本文介绍构建 gentoo 系统的编译器选择方案，及一些尤其引起的 bug 的解决方案，不涉及选择编译器的专业观点。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知 Gentoo 系统完全在本地构建。因此编译器的选择很大程度上决定了编译系统的耗时以及整个系统的性能。</p><p>用于构建整个 Gentoo 系统的编译器只推荐两个，gcc 与 clang。</p><p>gcc 由 GNU 出品，与 GNU linux 自然匹配度更高。因此选择 gcc 作为编译器是最稳妥的方案。</p><p>clang 被苹果公司支持，近年来发展速度迅速，也具备许多 gcc 不具备的特性。但 clang 编译 linux 系统尚不稳定。</p><p>目前，绝大多数使用 clang 编译出错的 bug 已有解决方案。但部分软件，比如 gcc、linux 内核等必须使用 gcc 构建。因此即便你选择 clang 作为主编译器，也必须保留 gcc 作为辅助编译器。</p><h2 id="使用-gcc-作为主编译器"><a href="#使用-gcc-作为主编译器" class="headerlink" title="使用 gcc 作为主编译器"></a>使用 gcc 作为主编译器</h2><p>gcc 是 gentoo 的默认编译器，且比较稳定，这里不作太多说明。</p><p>只是需要注意一点，测试分支的 gcc 存在许多不稳定因素，可能会造成编译错误。考虑到编译器对于系统的重要性，强烈建议保留稳定分支的 gcc。</p><ul><li>gcc 版本选择</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看系统中的gcc版本gcc-config --list-profiles# 选择需要的gccgcc-config number# 刷新配置source &#x2F;etc&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用-clang-作为主编译器"><a href="#使用-clang-作为主编译器" class="headerlink" title="使用 clang 作为主编译器"></a>使用 clang 作为主编译器</h2><p>详见<a href="https://wiki.gentoo.org/wiki/Clang">gentoo wiki</a></p><p>关于 clang 的安装，可以参考上面的链接。这里主要介绍将 clang 作为主编译器的必要配置。</p><p>首先，在<code>make.conf</code>中作如下设置。</p><pre class="line-numbers language-none"><code class="language-none">CC &#x3D; clangCXX &#x3D; clang++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时，clang 已经成为系统的默认编译器。接下来设置备选方案，即当软件无法用 clang 编译时，使用 gcc 编译。</p><p>在<code>/etc/portage/env</code>目录下创建<code>compiler-gcc</code>，写入</p><pre class="line-numbers language-none"><code class="language-none">CC &#x3D; gccCXX &#x3D; g++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在<code>/etc/portage/package.env</code>文件中写入如<code>sys-devel/gcc compiler-gcc</code>的内容，即可将该包的编译器设置为 gcc。</p><p>这一步可以通过<code>app-portage/flaggie</code>工具自动完成。其指令为<code>flaggie app-foo/bar +compiler-gcc</code>。</p><p>至此，配置完毕。当发现 clang 无法编译某软件而 gcc 可行时只需将其加入上述文件即可。</p><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>这里的编译选项主要指优化选项。为提高系统性能，你可以设置编译优化选项。但由此带来的问题是编译时间大大增长，更容易遇到 bug，过多的或者不合理的优化选项导致性能反而下降。</p><p>这里不介绍配置优化选项的具体内容，只通过大致的感受给出一个建议。基于亲身体会，优化与不优化差别并不大，至少以人的感官很难感觉出来。因此这里建议新手不要开启优化选项，至少是过多的优化选项，除非你是为了折腾。</p><p>就前文提到的 gcc 备选方案的配置，你也可以将其运用到为具体的包选择性开启优化选项。比如编辑<code>/etc/portage/env/compiler-gcc-flto</code>。</p><pre class="line-numbers language-none"><code class="language-none">CC&#x3D;&quot;gcc&quot;CXX&#x3D;&quot;g++&quot;CFLAGS&#x3D;&quot;-flto -march&#x3D;native -O2 -pipe&quot;CXXFLAGS&#x3D;&quot;$&#123;CFLAGS&#125;&quot;AR&#x3D;&quot;gcc-ar&quot;NM&#x3D;&quot;gcc-nm&quot;RANLIB&#x3D;&quot;gcc-ranlib&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再在<code>/etc/portage/package.env</code>中设置包的编译方案即可。</p><p>下一篇：<a href="https://www.niuiic.top/2020/08/06/gentoo-compile-error-handling/">Gentoo Compile Error Handling</a></p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Package Management</title>
      <link href="2020/08/05/gentoo-package-management/"/>
      <url>2020/08/05/gentoo-package-management/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo 教程目录</a></p><h1 id="Gentoo-包管理"><a href="#Gentoo-包管理" class="headerlink" title="Gentoo 包管理"></a>Gentoo 包管理</h1><p>本文介绍 gentoo 包管理系统核心配置，以清晰明了、简单易懂为原则，不涉及深层内容。</p><p>掌握本文内容足以应对绝大部分软件安装、管理问题。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Gentoo 的包管理系统是 Portage，详情可查看 emerge 的 man page 及以下链接。</p><p><a href="https://wiki.gentoo.org/wiki/Handbook:X86/Working/Portage/zh-cn">gentoo handbook</a></p><p><a href="https://wiki.gentoo.org/wiki/Portage">gentoo wiki</a></p><h2 id="Gentoo-软件仓库"><a href="#Gentoo-软件仓库" class="headerlink" title="Gentoo 软件仓库"></a>Gentoo 软件仓库</h2><p>Portage 对于软件的行为基于本地的 ebuild。 ebuild 相当于 arch 的 PKGBUILD，简单的说，ebuild 用于指导软件包及其依赖的构建。</p><ul><li>如何获取 ebuild</li></ul><p>绝大多数的 ebuild 或者说软件包都被包含在 gentoo 官方仓库中，只需同步软件仓库即可得到。</p><pre class="line-numbers language-none"><code class="language-none">emerge --sync# 或者emerge-webrsync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但部分软件并非由官方打包，其 ebuild 也不是官方维护。这些称为“野包”，可以通过添加其所属 overlay 后同步软件仓库获得。</p><ul><li>如何查找 ebuild</li></ul><p>假设你需要安装一个软件，但只知其一般名称，不清楚具体名称，且不清楚是否存在本地 ebuild。</p><p>首先通过<code>emerge -S package_name</code>模糊查询本地 ebuild。如果没有，访问<a href="https://packages.gentoo.org/">https://packages.gentoo.org/</a>查找所需软件。这里包含了所有官方维护的 ebuild 以及已注册的一些 overlay 中的 ebuild。如果还是没有，可以 google 或 github 搜索<code>gentoo package_name</code>。如果还是没有，可以尝试自己创建。</p><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><h3 id="gentookit"><a href="#gentookit" class="headerlink" title="gentookit"></a>gentookit</h3><p>gentookit 包含了一系列用于软件管理的工具，可以帮助用户管理软件包并跟踪其系统中正在发生的事情。对于新手而言，主要使用的是 euse（USE flag 管理工具）、revdep-rebuild（依赖修复工具）、eclean（源码及二进制包清理工具）。</p><p>详见<a href="https://wiki.gentoo.org/wiki/Gentoolkit">gentoo wiki</a></p><h3 id="eix"><a href="#eix" class="headerlink" title="eix"></a>eix</h3><p>eix 主要用于替代<code>emerge -S</code>，提供更好的搜索体验。对于新手而言，熟悉<code>eix package_name</code>以及<code>eix -I package_name</code>足以。</p><p>详见<a href="https://wiki.gentoo.org/wiki/Eix">gentoo wiki</a></p><h2 id="软件选项"><a href="#软件选项" class="headerlink" title="软件选项"></a>软件选项</h2><p>Gentoo 的包管理系统为软件定制设置了许多选项。其全局配置文件为<code>/etc/portage/make.conf</code>。</p><h3 id="USE-flag"><a href="#USE-flag" class="headerlink" title="USE flag"></a>USE flag</h3><p>简单的说，USE flag 就是指定软件功能的选项。比如你需要某软件的文档，那么就为该软件激活<code>doc</code>这个 USE flag。如果不需要文档，则将其关闭，设置为<code>-doc</code>。</p><ul><li>USE flag 设置分类</li></ul><p>一种分类方法是全局和局部。</p><p>全局配置文件<code>/etc/portage/make.conf</code>（以下简称<code>make.conf</code>）中可以设置<code>USE=&quot;clang nls&quot;</code>等全局 USE flag。</p><p>局部配置是为具体的包定制的，其配置位于<code>/etc/portage/package.use</code>。注意这可以是一个目录，也可以是一个文件。据个人经验，未防止自动更新配置文件时打乱注释，建议使用目录形式，为每个包单独设置一个配置文件。比如配置<code>sys-devel/gcc</code>的 USE flag，创建<code>/etc/portage/package.use/gcc</code>（文件名理论上可以任意取，但建议取用包名或部分包名）。在文件中添加<code>sys-devel/gcc fortran nls nptl openmp pch sanitize ssp lto</code>，其中<code>sys-devel/gcc</code>是包名，后面的都是 USE flag。当然你也可以分行写，每一行都是包名 + 一个 USE flag。</p><p>另一种分类方法是永久和临时。</p><p>永久的设置方式前面已经说明。同时 gentoo 还提供了一种临时使用 USE flag 的办法。这种临时方法也适用于很多其他选项。</p><p>比如安装 gcc，使用<code>USE=&quot;nls pch&quot; emerge sys-devel/gcc</code>即可。</p><ul><li>如何查看 USE flag</li></ul><p>使用<code>equery uses package_name</code>查看包当前 USE flag 的状态。</p><p>Equery 是使用<code>app-portage/gentoolkit</code>包安装的工具集的一部分。详见<a href="https://wiki.gentoo.org/wiki/Equery">gentoo wiki</a>。</p><p>也可以使用<code>eix package_name</code>查看。</p><p>如果你不知道每个 USE flag 的具体含义，可查看<a href="https://www.gentoo.org/support/use-flags/">https://www.gentoo.org/support/use-flags/</a>。也可以点击<a href="https://packages.gentoo.org/">https://packages.gentoo.org/</a>中包页面中的 USE flag 查看详情。对于一些重要且流行的包，如 kde 的 plasma，可以在其相关的 wiki 中找到 USE flag 说明。</p><h3 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h3><p>简单的说，keywords 用于告知软件在哪些架构下是稳定的、测试状态的或者未测试的。详见<a href="https://wiki.gentoo.org/wiki/KEYWORDS">gentoo wiki</a>。</p><p>以 amd64 为例，<code>KEYWORDS=amd64</code>表示接受所有已经在 amd64 架构下测试过的进入稳定分支的软件包。<code>KEYWORDS=~amd64</code>则表示接受所有在 amd64 架构下进入稳定分支和测试分支的软件包。</p><p>此外还有一些特殊形式的 KEYWORDS。但本质上是一样的。</p><p>如果软件的 ebuild 的 KEYWORDS 中不包含 amd64，则表明当前软件未在该架构下测试，或不可用。</p><ul><li>如何配置 keywords</li></ul><p>同样，在全局配置文件<code>make.conf</code>中可以配置<code>KEYWORDS=amd64</code>。</p><p>也可以在<code>/etc/portage/package.accept_keywords</code>中接受具体包的 keywords。同样这可以是一个目录，也可以是一个文件，建议设置为目录。在文件中写入<code>app-i18n/fcitx5-chinese-addons</code>之类的包全称即可。</p><p>这里还可以对包版本进行控制。如上例是接受该包所有版本的 keywords。若要接受指定版本，则<code>=x11-libs/xcb-imdkit-99999999999 **</code>。同样<code>&gt; &lt; &gt;= &lt;=</code>均是适用的。这也可以用于其他选项的配置。</p><ul><li>如何查看 keywords</li></ul><p><code>equery meta package_name</code>或者<code>eix package_name</code></p><p>建议使用<code>eix package_name</code>，结果如下</p><p><img src="1.png" alt="gcc"></p><p><img src="2.png" alt="kcm-fcitx5"></p><p>其中版本号前带<code>~</code>的为测试分支。特别注意带<code>(**)</code>的在配置文件中应当写入<code>=app-i18n/kcm-fcitx5-99999999 **</code>。直接写入<code>app-i18n/kcm-fcitx5</code>不会接受该版本。</p><ul><li>是否选择开启测试分支</li></ul><p>测试分支与稳定分支的差异无需多言。不过对于 gentoo 而言，有相当一部分“野包”并未进入稳定分支。因此软件的测试分支并不一定不稳定。</p><p>首先明确，新手绝不要在全局开启测试分支。一来，软件不稳定，bug 较多，新手无能力修复。二来更新频繁，电脑性能不足将严重影响体验感。最后，想再改到稳定分支难上加难。</p><p>是否需要为内核开启测试分支取决于计算机配置。截至本文攥写时，gentoo 稳定分支最新内核版本为 5.4.48，可能已经无法满足部分新机型需要。此时可以选择开启测试分支。gentoo 测试分支内核源码更新频率基本维持在几天一更。如果觉得过于频繁，可以指定测试分支版本或者隔几个版本编译一次内核。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>另外一个重要的选项是 license，即许可证。虽然 gentoo wiki 并不建议在全局接受所有许可证，但个人建议，如果你对此并不了解，完全可以在<code>make.conf</code>中直接设置<code>ACCEPT_LICENSE=&quot;*&quot;</code>。</p><p>对于新手而言，熟悉以上三个选项足以。</p><p>其他选项可以自行参考 gentoo wiki。</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>多版本软件并存是 gentoo 的一大特色，但事实上绝大多数软件并不具备该特性。</p><ul><li>如何查看是否可以多版本共存</li></ul><p><img src="3.png" alt="instance"></p><p>上图是<code>eix clang</code>的部分结果，其中 clang 与 clang-common 均存在多个可选版本。其中版本号前有<code>(number)</code>的 clang 可以多版本共存，而 clang-common 不可。</p><ul><li>如何控制软件版本</li></ul><p>临时设置可以直接在安装命令中指定，如<code>emerge &quot;=sys-devel/clang-9.0.1&quot;</code>。</p><p>如果需要永久固定软件版本，可以通过以下两种方案。</p><p>方案一：如果该软件版本处于测试分支，则在接受其 keyword 时，指定具体版本。当然，这并不能屏蔽稳定分支版本。因此仅适用于无稳定分支的软件。</p><p>方案二：对于方案一不可行的软件，可以在<code>/etc/portage/package.mask</code>中设置将该版本之后的所有版本屏蔽。如<code>&gt;=sys-power/powertop-1.97</code>。</p><h2 id="Portage-常见报错"><a href="#Portage-常见报错" class="headerlink" title="Portage 常见报错"></a>Portage 常见报错</h2><h3 id="被阻挡的包"><a href="#被阻挡的包" class="headerlink" title="被阻挡的包"></a>被阻挡的包</h3><ul><li>报错示例</li></ul><pre class="line-numbers language-none"><code class="language-none">!!! Error: the mail-mta&#x2F;postfix package conflicts with another package.!!!        both can&#39;t be installed on the same system together.!!!        Please use &#39;emerge --pretend&#39; to determine blockers.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>原因</li></ul><p>首先由报错信息可知，该软件包被阻挡显然是因为包冲突。一般是因为依赖冲突，包括编译依赖冲突和运行依赖冲突。</p><ul><li>解决方案</li></ul><p>如果你不熟悉 ebuild，不应当首先考虑修改 ebuild。如果可以二者取其一，则只需拆卸一个。如果二者都需要，可以考虑修改安装软件的版本，这可能助于避开依赖冲突。实在没有办法的情况下可以到<a href="https://bugs.gentoo.org/">Gentoo’s bugtracking system</a>提交 bug。</p><h3 id="被屏蔽的包"><a href="#被屏蔽的包" class="headerlink" title="被屏蔽的包"></a>被屏蔽的包</h3><ul><li>报错示例</li></ul><pre class="line-numbers language-none"><code class="language-none">!!! all ebuilds that could satisfy &quot;bootsplash&quot; have been masked.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">!!! possible candidates are:- gnome-base&#x2F;gnome-2.8.0_pre1 (masked by: ~x86 keyword)- lm-sensors&#x2F;lm-sensors-2.8.7 (masked by: -sparc keyword)- sys-libs&#x2F;glibc-2.3.4.20040808 (masked by: -* keyword)- dev-util&#x2F;cvsd-1.0.2 (masked by: missing keyword)- games-fps&#x2F;unreal-tournament-451 (masked by: package.mask)- sys-libs&#x2F;glibc-2.3.2-r11 (masked by: profile)- net-im&#x2F;skype-2.1.0.81 (masked by: skype-eula license(s))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>原因</li></ul><p>一般是由于 keyword（包未经测试，未进入稳定分支）、license（许可证未接受）、package.mask（软件包损坏或有严重问题）或 profile（软件不适合当前 profile）。</p><ul><li>解决方案</li></ul><p>首先明确处于最后两种情况的软件不应被安装。</p><p>前两种情况只需单独为包设置 keyword 或者 license 即可。</p><h3 id="USE-flag-的必要更改"><a href="#USE-flag-的必要更改" class="headerlink" title="USE flag 的必要更改"></a>USE flag 的必要更改</h3><ul><li>报错示例</li></ul><pre class="line-numbers language-none"><code class="language-none">The following USE changes are necessary to proceed:#required by app-text&#x2F;happypackage-2.0, required by happypackage (argument)&gt;&#x3D;app-text&#x2F;feelings-1.0.0 test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>原因</li></ul><p>USE flag 不满足当前软件包编译安装需要</p><ul><li>解决方案</li></ul><p>手动修改 USE flag 或者<code>etc-update</code></p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>依赖缺失、循环依赖等依赖方面的错误对于新手而言是个难题，如果你并没有能力自己修复，那么等上游修复 bug 后重试是最好的选择。</p><p>下载失败错误的一般原因应当不用多说，但也不排除 ebuild 中下载地址错误的情况。</p><p>下一篇：<a href="https://www.niuiic.top/2020/08/05/gentoo-compiler-selection/">Gentoo Compiler Selection</a></p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Choose vim to edit markdown and latex files</title>
      <link href="2020/08/04/vim-markdown-latex/"/>
      <url>2020/08/04/vim-markdown-latex/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-vim-编写-markdown-和-latex"><a href="#使用-vim-编写-markdown-和-latex" class="headerlink" title="使用 vim 编写 markdown 和 latex"></a>使用 vim 编写 markdown 和 latex</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="主要配置"><a href="#主要配置" class="headerlink" title="主要配置"></a>主要配置</h3><ul><li>操作系统：arch linux</li><li>编辑器：neovim（coc-actions 仅支持 neovim），如果使用 vim，请换用另外的补全插件</li><li>预览：markdown 使用 typora，latex 用 vimtex 调用 MuPDF</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>在使用 vim 之前，曾尝试了两种方案，一是 vscode + vim，配置简单，功能都还不错，问题是自动输入法切换延迟有点长，甚至使用方向键都有点卡，二是 jetbrains 系列的 ide，windows 下用来码字是体验最好的（linux 下对中文输入法不友好），但资源消耗太多，且预览不是很理想</p><p>下面是这套方案的优缺点</p><ul><li>linux 下 vim 的输入法切换体验远远好于 windows（笔者未使用 mac os，不清楚情况）</li><li>windows 下使用 texlive 安装 latex 相关依赖，编译 latex 文档时出现错误，暂时没能修复，linux 下比较稳定</li><li>neovim 以及 vim 比 vscode + vim 插件更流畅</li><li>支持 latex 即时编译，缺点是无法正反向搜索，这点在 vscode 中是支持的</li><li>typora 对 markdown 渲染的支持比 vim 以及 vscode 的相关插件好得多，比如支持本地 mp4 视频插入等，缺点是无法正反向搜索</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>以下步骤全靠回忆，不会有错，但可能有漏，请小心操作，避免掉坑，欢迎留言</li><li>由于网页的关系，直接从本文复制的内容可能存在非法字符，复制粘贴后应当检查一下</li><li>arch linux 可能帮你避开许多坑，如果想了解并使用 arch，可参考 arch wiki 安装教程，若水平有限，可以在网上搜索视频安装教程，还不行的话直接装 manjaro 吧</li><li>装好下面提到的软件时注意检查是否可以直接在终端调用</li></ul><h2 id="vim-简单配置"><a href="#vim-简单配置" class="headerlink" title="vim 简单配置"></a>vim 简单配置</h2><h3 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h3><p><a href="https://github.com/junegunn/vim-plug">github 地址</a></p><p>作者提供的安装方式应该是装不上的，似乎是这个链接本身有问题，不是 GFW 的锅</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>把项目克隆到本地，将项目中的 plug.vim 放到<code>~/.local/share/nvim/site/autoload</code>目录下，如果你使用 vim，可以放到<code>~/.vim/autoload</code>目录下</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>编辑<code>~/.config/nvim/init.vim</code></p><p>一个<code>Plug</code>对应一个插件，如果你和我一样只是想用 vim 编辑 markdown 和 latex（不包括 markdown 预览），那就直接 copy 吧（注意可以更换第一行<code>begin</code>后插件存放的路径）</p><p>插件依次为自动补全、文件树、文件浏览器（需要安装 nnn，没有的话就不要它了）、snippets 补全、snippets 补全、状态栏美化、自动格式化、markdown 支持、开始界面、latex 支持</p><p>部分本文未涉及的插件的具体用法请自行前往 github 查看，或者放弃使用</p><pre class="line-numbers language-none"><code class="language-none">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)Plug &#39;neoclide&#x2F;coc.nvim&#39;, &#123;&#39;branch&#39;: &#39;release&#39;&#125;Plug &#39;preservim&#x2F;nerdtree&#39;Plug &#39;mcchrish&#x2F;nnn.vim&#39;Plug &#39;SirVer&#x2F;ultisnips&#39;Plug &#39;honza&#x2F;vim-snippets&#39;Plug &#39;vim-airline&#x2F;vim-airline&#39;Plug &#39;Chiel92&#x2F;vim-autoformat&#39;Plug &#39;plasticboy&#x2F;vim-markdown&#39;Plug &#39;mhinz&#x2F;vim-startify&#39;Plug &#39;lervag&#x2F;vimtex&#39;call plug#end()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先别急着装插件，查看<a href="https://github.com/neoclide/coc.nvim/wiki/Install-coc.nvim">coc.nvim wiki</a>，先把依赖装了，主要是<code>nodejs</code>和<code>yarn</code>，作者给出的方法再次有点为难了，不过 arch linux 直接用包管理器装就行，其他的可能需要折腾一会儿</p><p>另外<a href="https://github.com/Chiel92/vim-autoformat">vim-autoformat</a>插件需要安装依赖，在 vim-autoformat 的 github 主页下查找，主要是<code>remark</code> for markdown 以及<code>latexindent.pl</code> for latex，arch 系 linux 可以先尝试从 aur 安装，不行的话可以按照 github 上作者给出的方式安装，大概又是一番折腾，特别注意，如果这两个软件无法在全局调用，需要在配置文件中加上<code>let g:formatterpath = [&#39;/some/path/to/a/folder&#39;, &#39;/home/superman/formatters&#39;]</code>，也可以选择创建符号链接使其可在全局调用（暂时有个问题，格式化 markdown 时会将其中的 latex 公式比如<code>$\frac&#123;&#125;&#123;&#125;$</code>变为<code>$\\frac&#123;&#125;&#123;&#125;$</code>，不过可以手动替换<code>\\</code>为<code>\</code>，或者也可以尝试其他的格式化工具，见补充部分）</p><p>重新进入 neovim，执行<code>:PlugInstall</code>，等待安装结束，退出</p><h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><p>剩余的配置如下，重要的在下面，从<code>&quot; vim snippets##########################################</code>开始，前面的除了前两行都是 copy 自<code>coc.nvim</code>的基础配置，不想细看就 copy 吧，如果只想编写 markdown 或 latex，则删除对应插件的配置，顺便把前面的插件也给删了</p><pre class="line-numbers language-none"><code class="language-none">set relativenumberset number&quot; TextEdit might fail if hidden is not set.set hidden&quot; Some servers have issues with backup files, see #649.set nobackupset nowritebackup&quot; Give more space for displaying messages.set cmdheight&#x3D;2&quot; Having longer updatetime (default is 4000 ms &#x3D; 4 s) leads to noticeable&quot; delays and poor user experience.set updatetime&#x3D;300&quot; Don&#39;t pass messages to |ins-completion-menu|.set shortmess+&#x3D;c&quot; Always show the signcolumn, otherwise it would shift the text each time&quot; diagnostics appear&#x2F;become resolved.set signcolumn&#x3D;yes&quot; Use tab for trigger completion with characters ahead and navigate.&quot; NOTE: Use command &#39;:verbose imap &lt;tab&gt;&#39; to make sure tab is not mapped by&quot; other plugin before putting this into your config.inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;444\ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :444\ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :444\ coc#refresh()inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;function! s:check_back_space() abort4let col &#x3D; col(&#39;.&#39;) - 14return !col || getline(&#39;.&#39;)[col - 1]  &#x3D;~# &#39;\s&#39;endfunction&quot; Use &lt;c-space&gt; to trigger completion.inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()&quot; Use &lt;cr&gt; to confirm completion, &#96;&lt;C-g&gt;u&#96; means break undo chain at current&quot; position. Coc only does snippet and additional edit on confirm.&quot; &lt;cr&gt; could be remapped by other vim plugin, try &#96;:verbose imap &lt;CR&gt;&#96;.if exists(&#39;*complete_info&#39;)4inoremap &lt;expr&gt; &lt;cr&gt; complete_info()[&quot;selected&quot;] !&#x3D; &quot;-1&quot; ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;else4inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;endif&quot; Use &#96;[g&#96; and &#96;]g&#96; to navigate diagnosticsnmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)nmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)&quot; GoTo code navigation.nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)&quot; Use K to show documentation in preview window.nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;function! s:show_documentation()4if (index([&#39;vim&#39;,&#39;help&#39;], &amp;filetype) &gt;&#x3D; 0)44execute &#39;h &#39;.expand(&#39;&lt;cword&gt;&#39;)4else44call CocAction(&#39;doHover&#39;)4endifendfunction&quot; Highlight the symbol and its references when holding the cursor.autocmd CursorHold * silent call CocActionAsync(&#39;highlight&#39;)&quot; Symbol renaming.nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)&quot; Formatting selected code.xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)augroup mygroup4autocmd!4&quot; Setup formatexpr specified filetype(s).4autocmd FileType typescript,json setl formatexpr&#x3D;CocAction(&#39;formatSelected&#39;)4&quot; Update signature help on jump placeholder.4autocmd User CocJumpPlaceholder call CocActionAsync(&#39;showSignatureHelp&#39;)augroup end&quot; Applying codeAction to the selected region.&quot; Example: &#96;&lt;leader&gt;aap&#96; for current paragraphxmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)&quot; Remap keys for applying codeAction to the current line.nmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)&quot; Apply AutoFix to problem on the current line.nmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)&quot; Map function and class text objects&quot; NOTE: Requires &#39;textDocument.documentSymbol&#39; support from the language server.xmap if &lt;Plug&gt;(coc-funcobj-i)omap if &lt;Plug&gt;(coc-funcobj-i)xmap af &lt;Plug&gt;(coc-funcobj-a)omap af &lt;Plug&gt;(coc-funcobj-a)xmap ic &lt;Plug&gt;(coc-classobj-i)omap ic &lt;Plug&gt;(coc-classobj-i)xmap ac &lt;Plug&gt;(coc-classobj-a)omap ac &lt;Plug&gt;(coc-classobj-a)&quot; Use CTRL-S for selections ranges.&quot; Requires &#39;textDocument&#x2F;selectionRange&#39; support of LS, ex: coc-tsservernmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)xmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)&quot; Add &#96;:Format&#96; command to format current buffer.command! -nargs&#x3D;0 Format :call CocAction(&#39;format&#39;)&quot; Add &#96;:Fold&#96; command to fold current buffer.command! -nargs&#x3D;? Fold :call     CocAction(&#39;fold&#39;, &lt;f-args&gt;)&quot; Add &#96;:OR&#96; command for organize imports of the current buffer.command! -nargs&#x3D;0 OR   :call     CocAction(&#39;runCommand&#39;, &#39;editor.action.organizeImport&#39;)&quot; Add (Neo)Vim&#39;s native statusline support.&quot; NOTE: Please see &#96;:h coc-status&#96; for integrations with external plugins that&quot; provide custom statusline: lightline.vim, vim-airline.set statusline^&#x3D;%&#123;coc#status()&#125;%&#123;get(b:,&#39;coc_current_function&#39;,&#39;&#39;)&#125;&quot; Mappings using CoCList:&quot; Show all diagnostics.nnoremap &lt;silent&gt; &lt;space&gt;a  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;&quot; Manage extensions.nnoremap &lt;silent&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;&quot; Show commands.nnoremap &lt;silent&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;&quot; Find symbol of current document.nnoremap &lt;silent&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;&quot; Search workspace symbols.nnoremap &lt;silent&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;&quot; Do default action for next item.nnoremap &lt;silent&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;&quot; Do default action for previous item.nnoremap &lt;silent&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;&quot; Resume latest coc list.nnoremap &lt;silent&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;&quot; vim snippets##########################################let g:UltiSnipsExpandTrigger&#x3D;&quot;&lt;tab&gt;&quot;let g:UltiSnipsJumpForwardTrigger&#x3D;&quot;&lt;c-b&gt;&quot;let g:UltiSnipsJumpBackwardTrigger&#x3D;&quot;&lt;c-z&gt;&quot;&quot; autoformat##########################################noremap &lt;C-L&gt; :Autoformat&lt;CR&gt;&quot; nerdtree##########################################map &lt;C-p&gt; :NERDTreeToggle&lt;CR&gt;&quot; vimtex##########################################let g:vimtex_view_general_viewer &#x3D; &#39;mupdf&#39;let g:vimtex_view_general_options_latexmk &#x3D; &#39;-reuse-instance&#39;let g:vimtex_view_general_options\ &#x3D; &#39;-reuse-instance -forward-search @tex @line @pdf&#39;\ . &#39; -inverse-search &quot;&#39; . exepath(v:progpath)\ . &#39; --servername &#39; . v:servername\ . &#39; --remote-send \&quot;^&lt;C-\^&gt;^&lt;C-n^&gt;&#39;\ . &#39;:execute &#39;&#39;drop &#39;&#39; . fnameescape(&#39;&#39;\%f&#39;&#39;)^&lt;CR^&gt;&#39;\ . &#39;:\%l^&lt;CR^&gt;:normal\! zzzv^&lt;CR^&gt;&#39;\ . &#39;:call remote_foreground(&#39;&#39;&#39;.v:servername.&#39;&#39;&#39;)^&lt;CR^&gt;^&lt;CR^&gt;\&quot;&quot;&#39;set conceallevel&#x3D;1let g:tex_conceal&#x3D;&#39;abdmg&#39;&quot; Prevent that vim detect a file with the tex suffix as a plaintexlet g:tex_flavor&#x3D;&#39;latex&#39;&quot; Set the viewer methodlet g:vimtex_view_method&#x3D;&#39;mupdf&#39;&quot; Never opened&#x2F;closed the quickfix window automatically. The quickfix window shows the errors and&#x2F;or warnings when compile, and we can open the quickfix windows use \lelet g:vimtex_quickfix_mode&#x3D;0&quot; 最后两行开启自动隐藏功能,开启了这个功能，除了你光标所在的那一行之外，文本里夹杂的LaTeX代码就都会隐藏或者替换成其他符号set conceallevel&#x3D;1let &amp;t_SI.&#x3D;&quot;\e[5 q&quot; &quot;SI &#x3D; INSERT modelet &amp;t_SR.&#x3D;&quot;\e[4 q&quot; &quot;SR &#x3D; REPLACE modelet &amp;t_EI.&#x3D;&quot;\e[1 q&quot; &quot;EI &#x3D; NORMAL mode (ELSE)inoremap &lt;C-c&gt; &lt;esc&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：格式化快捷键设置成了<code>ctrl + l</code>，<code>coc.nvim</code>可以使用<code>ctrl + n</code>选择提示项（只能往下翻，对我来说足够了，需要更好地体验可以自行设置），按<code>ctrl + p</code>打开文件树</p><h3 id="输入法自动切换"><a href="#输入法自动切换" class="headerlink" title="输入法自动切换"></a>输入法自动切换</h3><p>这部分很重要，极其影响体验感</p><p>首先确保你使用的是 fcitx 输入法，fcitx4 和 fcitx5 都可以</p><p><a href="https://www.vim.org/scripts/script.php?script_id=3764">下载最新版本的 fcitx.vim</a></p><p>解压后把 plugin 和 so 两个文件夹放到<code>~/.config/nvim</code>，或者干脆在这个目录下解压，如果是 vim，则应放到<code>~/.vim</code></p><p>这里有个坑，上面已经填了，配置文件最后一行<code>inoremap &lt;C-c&gt; &lt;esc&gt;</code>，将<code>ctrl + c</code>映射为<code>esc</code>，默认情况下两者都可以进入普通模式，但前者不会触发相关事件，这使得插件无效（不知有没有像我一样使用<code>ctrl + c</code>的 vimer）</p><p>如果你的<code>ctrl + c</code>在插入模式下另有用处，请删除该行</p><p>注意：作者并不是为 neovim 设计的插件，目前最新版本的 neovim 可以使用，但不意味着一直可以使用</p><h3 id="相关-python-依赖安装"><a href="#相关-python-依赖安装" class="headerlink" title="相关 python 依赖安装"></a>相关 python 依赖安装</h3><p>coc.nvim 需要 python 模块支持，另外 fcitx.vim 也需要 python 的 vim 模块以使用 fcitx.py 来获取更好的体验，不过这和 neovim 就没关系了，也可以装上，还有<code>autoformat</code>插件也需要 Python 模块</p><p>使用<code>pip</code>安装<code>python-vim</code>、<code>neovim</code>，并<code>python3 -m pip install pynvim</code></p><p>对于 gentoo，使用 pip 安装 python 模块需要加–usr 选项，这样安装的模块默认情况下是无法被 python 找到的，需要设置一下。如果不知如何解决，可以直接<code>emerge dev-python/pynvim</code>，其他的就无需安装</p><p>如果你的 neovim 找不到 Python3，则在 neovim 配置文件中加入<code>let g:python3_host_prog=/path/to/python/executable/</code>，路径自己改</p><h3 id="coc-nvim-配置"><a href="#coc-nvim-配置" class="headerlink" title="coc.nvim 配置"></a>coc.nvim 配置</h3><p>查看<a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions">coc extensions</a>，找到 markdown 和 latex 的对应扩展（按需安装），使用<code>:CocInstall</code>指令安装</p><p>此外，还需要安装<code>coc-snippets</code>和<code>coc-actions</code>以配合 snippets 相关插件</p><p>查看<a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers">coc language servers</a>，找到 markdown 和 latex，按照指示完成配置，如果遇到困难，继续往下看</p><p>这里使用<code>:CocConfig</code>指令打开 coc 配置文件，如果你不熟悉 json，特别注意，文件中的所有内容需要用<code>&#123;&#125;</code>包起来，直接 copy 作者给的配置会出现语法错误</p><p>这里安装<code>efm-langserver</code>和<code>digestif</code>又有问题了，arch 直接从 aur 安装再次避坑（需要先配置 go 语言环境，GOROOT 在 arch 上为<code>/usr/lib/go</code>，如果你上网找的话，可能会被<code>/usr/local/go</code>给坑了，go 安裝完毕后 GOROOT 下是有文件的，不确定是哪个可以去查看一下，另外还需要打开<code>go module</code>，以及给<code>go get</code>设置国内代理，详见<a href="https://blog.csdn.net/weixin_44690437/article/details/103571558">go 语言依赖管理</a>，试图那啥的可以省省了，<code>go get</code>不认这招，或许全系统代理可以），其他的可能需要折腾一会儿</p><p>这里附上我的<code>coc-settings.json</code>，copy 的时候把两个路径换成自己的，另外特别注意<code>command</code>需要使用绝对路径</p><pre class="line-numbers language-none"><code class="language-none">&#123;          languageserver : &#123;                   digestif : &#123;                          command :  &#x2F;bin&#x2F;digestif ,                          filetypes : [ tex ,  plaintex ,  context ]                 &#125;,                  efm : &#123;                          command :  &#x2F;bin&#x2F;efm-langserver ,                         args : [ -c ,  &#x2F;home&#x2F;yourUsername&#x2F;.config&#x2F;efm-langserver&#x2F;config.yaml ],                          filetypes : [ vim ,  eruby ,  markdown ]                 &#125;        &#125;,          suggest.noselect : false &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><p>markdown 的部分上面已经完成的差不多了，现在先创建一个.md 文件，查看是否可以补全，<code>nvim test.md</code>，输入<code>img</code>，应该会有提示，如果没有，请检查<code>coc.nvim</code>以及两个关于<code>snippets</code>的插件</p><p>目前还有一个至关重要的问题，markdown 中的 latex 无法补全，极其影响体验感，不过<code>coc.nvim</code>可以<a href="https://github.com/neoclide/coc.nvim/wiki/Create-custom-source">自定义 sources</a>，在<code>~/.config/nvim/autoload/coc/source</code>下创建<code>latex.vim</code>，写入</p><pre class="line-numbers language-none"><code class="language-none">function! coc#source#latex#init() abort4return &#123;4444\ &#39;triggerCharacters&#39;: [&#39;\&#39;],4444\&#39;filetype&#39;:[&#39;markdown&#39;]4444\&#125;endfunctionfunction! coc#source#latex#complete(opt, cb) abort4let items &#x3D; [&#39;dot&#123;&#125;&#39;, &#39;ddot&#123;&#125;&#39;, &#39;bar&#123;&#125;&#39;, &#39;hat&#123;&#125;&#39;, &#39;exp&#39;, &#39;sin&#39;, &#39;cos&#39;, &#39;tan&#39;, &#39;sec&#39;, &#39;csc&#39;, &#39;vec&#123;&#125;&#39;, &#39;cot&#39;, &#39;arcsin&#39;, &#39;arccos&#39;, &#39;arctan&#39;, &#39;sinh&#39;, &#39;cosh&#39;, &#39;tanh&#39;, &#39;coth&#39;, &#39;sh&#39;, &#39;ch&#39;, &#39;th&#39;, &#39;max&#39;, &#39;min&#39;, &#39;partial&#39;, &#39;nabla&#39;, &#39;prime&#39;, &#39;backprime&#39;, &#39;infty&#39;, &#39;eth&#39;, &#39;hbar&#39;, &#39;sqrt&#123;&#125;&#39;, &#39;sqrt[]&#123;&#125;&#39;, &#39;pm&#39;, &#39;mp&#39;, &#39;times&#39;, &#39;div&#39;, &#39;cdot&#39;, &#39;odot&#39;, &#39;bigodot&#39; , &#39;&#123; \&#125;&#39;, &#39;in&#39;, &#39;not&#39;, &#39;ni&#39;, &#39;cap&#39;, &#39;Cap&#39;, &#39;bigcap&#39;, &#39;cup&#39;, &#39;Cup&#39;, &#39;bigcup&#39;, &#39;subset&#39;, &#39;supset&#39;, &#39;supseteq&#39;, &#39;subseteq&#39;, &#39;subseteqq&#39;, &#39;supseteqq&#39;, &#39;subsetneq&#39;, &#39;supsetneq&#39;, &#39;supsetneqq&#39;, &#39;subsetneqq&#39;, &#39;sim&#39;, &#39;approx&#39;, &#39;leq&#39;, &#39;geq&#39;, &#39;parallel&#39;, &#39;nparallel&#39;, &#39;perp&#39;, &#39;angle&#39;, &#39;Box&#39;, &#39;bigtriangleup&#39;, &#39;bigtriangledown&#39;, &#39;forall&#39;, &#39;therefore&#39;, &#39;because&#39;, &#39;overline&#123;&#125;&#39;, &#39;Rightarrow&#39;, &#39;Leftarrow&#39;, &#39;rightarrow&#39;, &#39;leftarrow&#39;, &#39;leftrightarrow&#39;, &#39;nRightarrow&#39;, &#39;nLeftarrow&#39;, &#39;nleftarrow&#39;, &#39;nrightarrow&#39;, &#39;nleftrightarrow&#39;, &#39;overleftarrow&#123;&#125;&#39;, &#39;overrightarrow&#123;&#125;&#39;, &#39;overset&#123;&#125;&#39;, &#39;underline&#123;&#125;&#39;, &#39;sum&#39;, &#39;prod&#39;, &#39;lim&#39;, &#39;limits&#39;, &#39;int&#39;, &#39;iint&#39;, &#39;oint&#39;, &#39;iiint&#39;, &#39;frac&#123;&#125;&#123;&#125;&#39;, &#39;tfrac&#123;&#125;&#123;&#125;&#39;, &#39;dfrac&#123;&#125;&#123;&#125;&#39;, &#39;\begin&#123;matrix&#125;\end&#123;matrix&#125;&#39;, &#39;\begin&#123;vmatrix&#125;\end&#123;vmatrix&#125;&#39;, &#39;\begin&#123;bmatrix&#125;\end&#123;bmatrix&#125;&#39;, &#39;\begin&#123;Bmatrix&#125;\end&#123;Bmatrix&#125;&#39;, &#39;\begin&#123;pmatrix&#125;\end&#123;pmatrix&#125;&#39;,&#39;\begin&#123;cases&#125;\end&#123;cases&#125;&#39;, &#39;\begin&#123;aligned&#125;\end&#123;aligned&#125;&#39;, &#39;\begin&#123;array&#125;\end&#123;array&#125;&#39;, &#39;alpha&#39;, &#39;psi&#39;, &#39;Delta&#39;, &#39;delta&#39;, &#39;beta&#39;, &#39;lambda&#39;, &#39;rho&#39;, &#39;varepsilon&#39;, &#39;Gamma&#39;, &#39;chi&#39;, &#39;mu&#39;, &#39;sigma&#39;, &#39;Lambda&#39;, &#39;tau&#39;, &#39;varphi&#39;, &#39;varPhi&#39;, &#39;phi&#39;, &#39;Phi&#39;, &#39;eta&#39;, &#39;omega&#39;, &#39;varrho&#39;, &#39;Pi&#39;, &#39;pi&#39;, &#39;gamma&#39;, &#39;xi&#39;, &#39;Psi&#39;, &#39;Sigma&#39;, &#39;varnothing&#39;, &#39;iiiint&#39;]4call a:cb(items)endfunction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于自定义 source 的具体细节，请前往 github，上面给出的 source 设定在 markdown 文件下加载，使用<code>\</code>作为触发符，这里只加入了我常用的几个命令，更多内容可以自行添加</p><p>到此，markdown 部分已经完成，可以先检查一下有没有问题</p><h2 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h2><p>首先安装 latex 编译环境，这里使用 texlive</p><p>参考<a href="https://wiki.archlinux.org/index.php/TeX_Live_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">arch wiki</a>，不想折腾的话就把安装部分提到的几个包全装了，应该就问题不大了</p><p>如果还有问题，或者是其他 linux 发行版，可以参考<a href="https://zhuanlan.zhihu.com/p/40053417">Deepin Linux 安装和搭建 LaTex 环境</a>和<a href="https://blog.csdn.net/qq_41814939/article/details/82288145">Ubuntu18.04 安装 LaTeX 并配置中文环境</a>，不过安装 texlive-full 实在太麻烦了，我装了 3 小时，最后似乎卡住了，手贱中断了，再也装不上了，这个包和前面 arch wiki 中提到的包大部分是冲突的，如果是 arch 系的就不要折腾这个了，如果是 gentoo 的话，如果坚持本地编译的话，建议备好电影小零食~~（窃以为使用 gentoo 的 linux 骨灰级玩家不需要这篇文章，强行 gentoo 的玩家可能还没从坑里爬出来）</p><p>安装 MuPDF，当然你也可以选择别的，详见<a href="https://github.com/lervag/vimtex">github</a>，如果换了的话需要把上面的配置也一并修改</p><p>到此结束，测试一下，<code>nvim test.tex</code>，写入</p><pre class="line-numbers language-none"><code class="language-none">\documentclass&#123;article&#125;\begin&#123;document&#125;你好，world!\end&#123;document&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在普通模式下按<code>\ll</code>进行编译，再按<code>\lv</code>预览，不要关闭预览窗口，修改成<code>hello world</code>，保存，重新编译，看看预览是否同步改变，这里还可以设置保存时自动编译</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ul><li>linux 下没有可以和 FastStone 媲美的截图软件，不过可以用 KolourPaint 快速编辑图片，需要更多操作可以使用 GIMP，不建议使用 Pinta，由于无法输入中文</li><li>markdown 中可以用 html 语法插入 mp4 视频，比起 gif 的好处就不用多说了，缺点是略显臃肿</li><li>可以再为 vim 配置更多插件，比如 markdown 自动贴图、markdown 预览等等，也可以继续自定义 snippets，这些部分按个人喜好配置，这里不再介绍</li><li>桌面推荐 i3，i3 配置较为麻烦，可以保留原有桌面，简单配置 i3，仅用来写 markdown 和 latex</li><li>或许可以在 WSL 中配置，不过暂时折腾到此为止了</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="为-markdown-添加大纲显示"><a href="#为-markdown-添加大纲显示" class="headerlink" title="为 markdown 添加大纲显示"></a>为 markdown 添加大纲显示</h3><h4 id="Excuberant-Ctags"><a href="#Excuberant-Ctags" class="headerlink" title="Excuberant Ctags"></a>Excuberant Ctags</h4><p>首先安装<code>Excuberant Ctags</code>，debian 系和 redhat 系应该可以使用包管理工具直接安装，arch 这次似乎进坑了，需要编译源码</p><p>访问<a href="http://ctags.sourceforge.net/">Excuberant Ctags 下载页面</a>，没错，GFW 警告，这个资源可以在网上搜，文件名为 ctags-5.8，csdn 上有，本来想上传一个免费的，结果死活都重复，算了</p><p>解压，cd 入目录，<code>./configure</code>，继续<code>make &amp;&amp; sudo make install</code>，正常情况下应该没问题了，如果有问题，请参考<a href="https://blog.csdn.net/dream2009gd/article/details/44102227">安装 Exuberant Ctags 及 Tag List 插件</a></p><h4 id="easytags"><a href="#easytags" class="headerlink" title="easytags"></a>easytags</h4><p>使用<code>vim-plug</code>安装</p><pre class="line-numbers language-none"><code class="language-none">Plug &#39;xolox&#x2F;vim-misc&#39;Plug &#39;xolox&#x2F;vim-easytags&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="tagbar"><a href="#tagbar" class="headerlink" title="tagbar"></a><a href="https://github.com/majutsushi/tagbar">tagbar</a></h4><pre class="line-numbers language-none"><code class="language-none">Plug &#39;majutsushi&#x2F;tagbar&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意使用该插件时可能有问题，详情见 github</p><h4 id="markdown2ctags"><a href="#markdown2ctags" class="headerlink" title="markdown2ctags"></a>markdown2ctags</h4><pre class="line-numbers language-none"><code class="language-none">Plug &#39;jszakmeister&#x2F;markdown2ctags&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre class="line-numbers language-none"><code class="language-none">&quot; tagbar#####################################nmap &lt;C-M&gt; :TagbarToggle&lt;CR&gt;&quot; markdown2ctags#####################################let g:tagbar_type_markdown &#x3D; &#123;    \ &#39;ctagstype&#39;: &#39;markdown&#39;,    \ &#39;ctagsbin&#39; : &#39;&#x2F;home&#x2F;yourUsername&#x2F;.vim&#x2F;plugged&#x2F;markdown2ctags&#x2F;markdown2ctags.py&#39;,    \ &#39;ctagsargs&#39; : &#39;-f - --sort&#x3D;yes --sro&#x3D;»&#39;,    \ &#39;kinds&#39; : [        \ &#39;s:sections&#39;,        \ &#39;i:images&#39;    \ ],    \ &#39;sro&#39; : &#39;»&#39;,    \ &#39;kind2scope&#39; : &#123;        \ &#39;s&#39; : &#39;section&#39;,    \ &#125;,    \ &#39;sort&#39;: 0,\ &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里给 tagbar 的快捷键设置为<code>ctrl + m</code>，<code>markdown2ctags</code>的配置中需要注意更换你的<code>markdown2ctags.py</code>所在路径，且注意通过<code>:set filetype</code>查看你的 markdown 文件的文件类型名称是否是 markdown，若不是，则修改<code>ctagstype</code></p><h3 id="格式化插件neoformat"><a href="#格式化插件neoformat" class="headerlink" title="格式化插件neoformat"></a>格式化插件<a href="https://github.com/sbdchd/neoformat">neoformat</a></h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><pre class="line-numbers language-none"><code class="language-none">Plug &#39;sbdchd&#x2F;neoformat&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h4><h5 id="prettier-for-markdown"><a href="#prettier-for-markdown" class="headerlink" title="prettier for markdown"></a><a href="https://github.com/prettier/prettier">prettier</a> for markdown</h5><p>不要选 remark 作为格式化软件</p><p>arch 可以直接从 aur 安装，其他参考<a href="https://prettier.io/docs/en/install.html">install prettier</a></p><h5 id="latexindent-pl-for-latex"><a href="#latexindent-pl-for-latex" class="headerlink" title="latexindent.pl for latex"></a><a href="https://github.com/cmhughes/latexindent.pl">latexindent.pl</a> for latex</h5><p>将项目 clone 到本地</p><p>安装<code>perl</code>，执行<code>sudo cpan</code></p><p>进入<code>cpan</code>环境后，执行</p><pre class="line-numbers language-none"><code class="language-none">install Log::Log4perlinstall Log::Dispatch::Fileinstall YAML::Tinyinstall File::HomeDir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再次 GFW 警告</p><p>进入项目目录，测试 latexindent.pl 是否可以正常运行，并设置为可全局调用（最简单的方式是写个 sh 文件，<code>cd youPathToLatexindent.pl &amp;&amp; ./latexindent.pl</code>，然后将其链接到<code>/bin</code>或者<code>/usr/bin</code>）</p><h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><p>只需在<code>init.vim</code>中添加</p><pre class="line-numbers language-none"><code class="language-none">let g:neoformat_latex_latexindent &#x3D;&#123;&#39;exe&#39;:&#39;latexindent&#39;,&#39;args&#39;:[],&#39;stdin&#39;:1&#125;let g:neoformat_enabled_latex&#x3D;[&#39;latexindent&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用 prettier 格式化 markdown 失败，笔者暂时未解决该错误，可以使用<a href="https://github.com/prettier/vim-prettier">vim-prettier</a>插件代替，或者手动运行<code>prettier --wirte pathToYourFile</code></p><p>为不同类型的文件添加格式化快捷键</p><pre class="line-numbers language-none"><code class="language-none">nnoremap &lt;C-l&gt; :Neoformat&lt;CR&gt;autocmd FileType markdown nnoremap &lt;buffer&gt; &lt;C-l&gt; :Prettier&lt;CR&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Markdown </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo Preface</title>
      <link href="2020/08/04/gentoo-preface/"/>
      <url>2020/08/04/gentoo-preface/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.niuiic.top/2020/08/06/gentoo-tutorials-directory/">Gentoo 教程目录</a></p><h1 id="Gentoo-教程：前言"><a href="#Gentoo-教程：前言" class="headerlink" title="Gentoo 教程：前言"></a>Gentoo 教程：前言</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本教程旨在帮助 gentoo 入坑者快速熟悉 gentoo 系统基本操作。</p><p>你应当可以在完成本教程后成功安装，配置 gentoo 系统。并具备一定维护能力。</p><p>笔者并非专业人士，文中涉及的部分操作可能并不合适。但对于新手而言应当是非常有效的。</p><p>参考来源：</p><p><a href="https://wiki.gentoo.org/wiki/Main_Page">gentoo wiki</a><br><a href="https://wiki.archlinux.org/">arch wiki</a><br><a href="https://forums.gentoo.org/">gentoo forums</a><br><a href="https://wiki.gentoo.org/wiki/Handbook:Main_Page/zh-cn">gentoo handbook</a><br><a href="https://www.gentoo.org/support/documentation/">gentoo documentation</a></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>必须对 linux 系统有一定了解，且比较熟悉命令行。（如果你能安装 arch，就足以尝试安装 gentoo）</li><li>电脑配置及格。</li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>官方 wiki 是最好的教程，但比较零散。强烈建议参考本教程的步骤，结合官方 wiki，进行操作。</li><li>先在虚拟机中尝试，方便回滚，减少犯错的时间成本。</li><li>切勿急于求成，一定要保证配置好编译选项以及内核。</li></ul><h2 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h2><p><img src="1.png" alt="Gentoo Linux with Kool Desktop Environment"></p><p>下一篇：<a href="https://www.niuiic.top/2020/08/05/gentoo-package-management/">Gentoo Package Management</a></p>]]></content>
      
      
      <categories>
          
          <category> Gentoo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
